<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客主题NexT相关配置]]></title>
    <url>%2F2019%2F02%2F27%2Fblog%2Fblog-theme-set%2F</url>
    <content type="text"><![CDATA[因为我的Hexo博客用的是NexT主题，故其他主题的配置我不是很清楚。 主题配置文件路径为：themes/next/_config.yml 一、主题风格以下操作均在_config.yml文件内进行。 修改scheme属性可以修改NexT主题的风格 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 修改menu属性可以修改主题的菜单项 1234567891011121314151617181920212223# ---------------------------------------------------------------# Menu Settings 菜单设置# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || home # 首页 about: /about/ || user # 关于 tags: /tags/ || tags # 标签 categories: /categories/ || th # 分类 archives: /archives/ || archive # 归档 #schedule: /schedule/ || calendar # 日程 #sitemap: /sitemap.xml || sitemap # 网站地图 #commonweal: /404/ || heartbeat# 是否使用网站icon# Enable/Disable menu icons.menu_icons: enable: true 添加tags(标签页)、categories(分类)、archives(归档)、about(关于)菜单项需要新建对应的页面，如果未新建对应的页面，点击菜单项跳转后会提示page not found，新建页面需要在网站根目录下打开终端，然后输入： 1234hexo n page "tages" # 新建标签页hexo n page "categories" # 新建分类页hexo n page "archives" # 新建归档页hexo n page "about" # 新建关于页 新建菜单页后会在source/下生成一个新的目录，目录名对应tags、categories等。 进入对应的目录下可以看到一个index.md文件，用编辑器打开之后内容为(此处用tags目录下的index.md做举例，其他的类似)： 1234---title: tagsdate: 2019-02-26 13:42:22--- 然后在date属性下面添加一个type属性，作用是设置该md文件的类型： 12345---title: tagsdate: 2019-02-26 13:42:22type: "tags" # 这是新添加的--- 二、引入评论功能Hexo支持多种评论平台，我使用的是Gitment，这是一个基于GitHub issues的第三方评论系统，他使用了你的GtiHub仓库中的issues作为评论系统。效果可以查看Gitment DEMO。 我选择Gitment的原因主要有： Gitment是基于GitHub issues开发的评论系统，而我的博客就是通过GitHub搭建的，使用起来会更加方便。 我的博客主要是用于记录我在JavaScript、VUE、Node.js等知识学习中遇到的一些问题以及我的学习心得，主要内容以代码为主，所以对GitHub的东西有一种“特殊”的感情。 Gitment的评论会直接添加在我对应的GitHub issues中，我在查看评论时会更加的方便。 接下来就开始我们的添加之旅吧~ 首先在博客 申请一个Github OAuth Application，注册地址 注意，在Authorization callback URL这一栏一定要填写你的网站url，即：`https://xxx.github.io` 注册成功之后你会获得一个Client ID和Client Secret，用于之后的Gitment评论系统登录。 修改NexT主题的配置文件，路径为：博客根目录/theme/_config.yml，找到Gitment属性（如果没有可以自行添加） 其中github_user是你的GitHub账户名，github_repo则是你这个仓库名（这个仓库名是用于存放你的评论位置的，一般用一个空仓库或者博客的仓库，不要在此填写仓库连接，填写仓库名就行了），client_id是我们在步骤2注册成功后GitHub给我们的Client ID，client_secret是刚才的Client Secret。注意：在:之后必须添加一个空格 在主题的根目录下我们打开~/layout/_third-party/comments/，在该目录下编辑gitment.swig文件内容（该文件一般为NexT主题自带）。我们需要将gitment的部分link的href更换，因为gitment使用的是GitHub的服务器，存在跨域的问题，原作者的网站证书失效了，所以我们需要修改并引用别人的.css和.js文件替换掉来解决跨域问题，要不然在登录gitment的时候会alert报错[object ProgressEvent]。 在这里我百度了一下问题，给大家列出两个解决方案： 修改浏览器设置，将https://gh-oauth.imsun.net/加入例外，但是别人浏览你的博客的时候不一定会添加。 修改~/layout/_third-party/comments/gitment.swing文件，将里面的https://imsun.github.io/gitment/style/default.css替换为https://www.wenjunjiang.win/css/gitment.css；https://imsun.github.io/gitment/dist/gitment.browser.js替换为https://www.wenjunjiang.win/js/gitment.js 使用方案2记得要将NexT主题的设置中的gitment下的mint属性修改为false 到这里基本你在你的博客博文下都能看到gitment的评论框了，不过使用之前还需要做两个步骤： 博客的主人需要登录并绑定对应的GitHub帐号； 登录之后需要对每篇博文下的评论功能进行初始化，需要一篇篇的点（无奈的表情渐渐浮现），不过网上有人写了批处理脚本，但是我没尝试过。 到了，到此Hexo+GitHub搭建博客的文章基本结束了，以后还有什么遇到的坑我会继续补充的。]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的设置]]></title>
    <url>%2F2019%2F02%2F27%2Fblog%2Fblog-set%2F</url>
    <content type="text"><![CDATA[一、Hexo配置文件说明 Hexo的配置文件位置是：~/_config.yml 在编辑配置文件的时候，在相应的设置项的:之后一定要添加一个空格。 其他一些详细的设置可以参考官方文档(中文) 在这里我着重讲解我的配置文件，可以作为你自己Hexo博客的配置参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息设置# Site# 网站标题title: HuangJunjia's Blog# 网站副标题subtitle: # 网站描述description:# 网站关键字keywords:# 网站作者昵称author: HuangJunjia# 网站语言，默认为英语，此处设置为简中language: zh-Hans# 时区，默认为电脑时区timezone:# 博客网址设置# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# 网址，如果你的博客是放在某个目录的子目录之下，需要将该设置修改为 'http://yoursite.com/child'url: http://yoursite.com# 根目录，如果你的博客是放在某个目录的子目录之下，需要将该设置修改为 '/child/'root: /# 文章链接地址格式 。即文章存放的目录。permalink: :year/:month/:day/:title/permalink_defaults:# 目录设置# Directory# 资源文件夹source_dir: source# 公共文件夹，用于存放 hexo g 生成的静态文件public_dir: public# 标签文件夹，默认为tags，路径为：./source/tagstag_dir: tags# 归档文件夹，默认为archives，路径为：./source/archivesarchive_dir: archives# 分类文件夹，默认为categories，路径为：./source/categoriescategory_dir: categories# 代码文件夹，默认为code，路径为：./downloads/codecode_dir: downloads/code# 国际化文件夹，默认跟language相同i18n_dir: :lang# 不需要渲染的文件夹或文件夹,放在[]中# 这两个文件是百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render:# 写作选项# Writing# 新建博文的默认名称new_post_name: :title.md # File name of new posts# 默认布局模版default_layout: post# 是否将标题转换成标题形式，即首字母大写titlecase: false # Transform title into titlecase# 在新标签页中打开网页external_link: true # Open external links in new tabfilename_case: 0# 是否渲染草稿render_drafts: false# 是否启动Asset文件夹post_asset_folder: true# 是否将链接改写成根目录的相对地址relative_link: false# 是否显示未来的文章future: true# 博文中代码块的设置highlight: enable: true # 是否使代码高亮 line_number: true # 是否显示行号 auto_detect: false # 是否自动检测语言 tab_replace: # 分页设置# @-----以下设置需要安装对应插件：# hexo-generator-index# hexo-generator-archive# hexo-generator-category# hexo-generator-tag# @-----END# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)# 首页分页设置index_generator: path: '' per_page: 10 # 首页每页显示文章数 order_by: -date # 分类与标签# Category &amp; Tag# 默认分类default_category: uncategorized# 分类别名category_map:# 标签别名tag_map:# 日期 / 时间格式# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示文章数pagination_dir: page # 分页路径，在public中可以查看# 主题设置# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next # 选择主题# 部署设置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 部署类型 repo: git@github.com:HuangJunjia/HuangJunjia.github.io.git # 部署连接地址 branch: master # 部署到git的分支名 # 搜索配置# 该功能需要提前安装插件# hexo-generator-search# searchsearch: path: search.xml field: post # post为仅索引文章，若想索引全部则设置为all format: html limit: 10000 二、如何安装Hexo的主题 Hexo默认主题是landscape 若需要修改主题，可以在Hexo官方主题中下载你想安装的主题 将下载好的主题放入themes目录下 我选择的主题是NexT 三、添加引入图片的功能先吐槽一下Hexo，他的图片引入功能很坑，用相对路径的方式引入图片会发现引入失败。我们需要在博客根目录下安装插件hexo-asset-image，之后我们通过hexo n &quot;new file&quot;的时候会在_post目录下生成一个同名的目录，我们将需要引入的图片放入那个目录下，之后引用图片就可以用相对路径引入了 1![newFile/img.png] 三、参考博文《hexo教程系列——hexo配置教程》 下一篇博文将会介绍一些NexT主题的相关配置]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建一个Blog]]></title>
    <url>%2F2019%2F02%2F26%2Fblog%2Fblog-build%2F</url>
    <content type="text"><![CDATA[今天突发奇想，自己搭建一个blog就可以不用github那个markdown来撰写我的博文了，然后去百度搜了一下，网友推荐了使用Hexo（当然还有其他）搭建一个自己的blog。 一、前期准备 一个GitHub帐号 一个名称为YourName.github.io的仓库 安装Git 安装Node.js 安装Hexo 前4步操作直接百度就好，我在此主要讲建立Blog的主要过程以及一些需要注意的问题和坑。因为我个人使用的是Windows的系统，在此不讲解其他系统的搭建过程，但是大同小异，可以参考。 二、安装Hexo 在确保你安装好Git的前提下，在终端中输入： 1npm install hexo-cli -g 然后在终端中输入： 1hexo v 若出现下图则说明你已经成功安装Hexo。 创建一个目录，作为你的blog目录。 进入该目录。 初始化该目录，初始化的过程可能会稍微花费一些时间； 1hexo init 当终端中显示INFO Start blogging with Hexo!的时候说明初始化成功了。 安装Hexo运行所需要的相关组件及依赖； 1npm install //或者 yarn 我个人推荐使用后者 如果终端中未出现ERROR等错误提示，WARN警告我们直接忽略就好。 在终端中输入： 1hexo s 启动服务器， 如此显示说明Hexo已经启动了，我们就可以进入有下划线的网址http://localhost:4000浏览我们的博客长啥样了。 到此为止，Hexo的安装已经结束了。 三、将我们的Hexo博客部署在我们的Username.github.io仓库中 新建一个仓库，仓库名必须为xxx.github.io，一般xxx与你GitHub昵称相同。 因为Hexo部署需要通过GitHub的ssh连接，所以需要配置一个ssh key，配置方法百度即可。 安装hexo-deployer-git插件（非常重要） 1npm install hexo-deployer-git //或者 yarn add hexo-deployer-git 修改Hexo的配置文件_config.yml，连接你的GitHub仓库， type设置为git，repo填写你的GitHub仓库地址，branck填写master 在终端中按住ctrl + c结束正在运行的Hexo服务，然后输入： 1hexo g //生成部署的文件，在public目录下 接着输入： 1hexo d //将生成的部署文件上传到我们之前新建的GitHub仓库中 因为打印的日志有点多，我就截取主要部分。 出现最后一行说明我们已经成功的将我们的Hexoblog部署到我们的GitHub仓库中了。 这时我们可以打开GitHub进入我们的仓库查看上传的文件有哪些。 到这里就差最后一步了！ 修改GitHub仓库设置，在GitHub Pages中修改选中的分支，将分支修改为master branch，等待页面刷新之后，我们就可以拿到https://xxx.github.io这个网址了~（这里因为我之前有建立过blog，所以就直接拿我之前blog的设置来做例子了~） 这个时候，我们打开网址，即https://xxx.github.io，就可以看到我们的Hexo博客了！记得xxx是你当初设置的~记得替换。（可能在设置完GitHub Pages之后需要等个几分钟才能看到我们的页面） 四、安装过程中可能会碰到的问题 问题1：4000端口被占用，无法启动服务 解决方法：改变服务器的端口号 1hexo s -p 端口号 // 端口号可以是未被占用的 五、后记可能会有一些小细节没处理好，如果按照我的方法出现部署失败的，可以在评论里留言，我一定会认真回复的。 下一篇文章我将会讲解Hexo的一些设置以及NexT主题的相关设置，增加评论功能等。]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐 for electron开发日记]]></title>
    <url>%2F2019%2F02%2F26%2FNeteseCloudMusic%2FFullApp%2FNeteseCloudMusicDiary%2F</url>
    <content type="text"><![CDATA[简介：使用electron-vue模版开发，非常感谢@Greg Holguin大大的electron-vue项目，以及使用的网易云音乐nodejs版的api的作者@Binaryify大大，他们俩是促使我尝试制作这个项目的原因。 项目地址网易云音乐 for electron 开发进度 header部分 logo区域： 已完成 icon的设置，title的设置 未完成 无 search区域： 已完成： 样式设计和编写 input事件触发搜索结果 未完成： 点击搜索图标跳转至搜索结果页面未制作 点击input触发的推荐结果跳转至对应的结果页未制作 setting区域： 已完成： 完成图标的制作 未完成： 对应功能未实现 视窗操作区域： 已完成： 图标按钮 当前窗口最小化、最大化/还原、关闭操作 未完成： 无 项目开发流程一、前期准备 node.js 官网 vue 官网 electron-vue模版 项目地址 该项目的目的，是为了要避免使用 vue 手动建立起 electron 应用程序。electron-vue 充分利用 vue-cli 作为脚手架工具，加上拥有 vue-loader 的 webpack、electron-packager 或是 electron-builder，以及一些最常用的插件，如vue-router、vuex 等等。 以上为官网介绍。 安装方式： 12345678# 安装 vue-cli 和 脚手架样板代码npm install -g vue-clivue init simulatedgreg/electron-vue my-project# 安装依赖并运行你的程序cd my-projectyarn # 或者 npm installyarn run dev # 或者 npm run dev 拉取网易云音乐 Node.js API service的github项目 项目地址 1git clone https://github.com/Binaryify/NeteaseCloudMusicApi.git 二、将网易云音乐API整合到electron-vue项目中并能够顺利启动服务该项目的网易云API是已经封装好的，但是需要单独的启动node.js，端口为3000，这样会显得比较麻烦，直接使用一个node.js的配置文件就足够了。 ps：因为该项目目前还在保持更新，若大家怕在后续的更新中需要重新修改配置，推荐大家直接在网易云API中直接启动node服务，我这里只是提供了我需要的一种方式。 过程： 拷贝网易云音乐API目录下的./module和./util目录，复制到electron-vue项目根目录下，此时目录结构应该如下： 12345678910electron-vue |-- .electron-vue |-- build |-- dist |-- node_modules |-- module |-- src |-- static |-- util ... 将网易云音乐API目录下app.js中的代码复制到electron-vue目录下的.electron-vue/dev-runner.js中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182......const fs = require('fs')const express = require('express')const bodyParser = require('body-parser')const request = require('../util/request')const cache = require('apicache').middleware......# 以下为网易云API的node服务代码const app = express()// CORSapp.use((req, res, next) =&gt; &#123; if(req.path !== '/' &amp;&amp; !req.path.includes('.'))&#123; res.header(&#123; 'Access-Control-Allow-Credentials': true, 'Access-Control-Allow-Origin': req.headers.origin || '*', 'Access-Control-Allow-Headers': 'X-Requested-With', 'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS', 'Content-Type': 'application/json; charset=utf-8' &#125;) &#125; next()&#125;)// cookie parserapp.use((req, res, next) =&gt; &#123; req.cookies = &#123;&#125;, (req.headers.cookie || '').split(/\s*;\s*/).forEach(pair =&gt; &#123; let crack = pair.indexOf('=') if(crack &lt; 1 || crack == pair.length - 1) return req.cookies[decodeURIComponent(pair.slice(0, crack)).trim()] = decodeURIComponent(pair.slice(crack + 1)).trim() &#125;) next()&#125;)// body parserapp.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123;extended: false&#125;))// cacheapp.use(cache('2 minutes', ((req, res) =&gt; res.statusCode === 200)))// staticapp.use(express.static(path.join(__dirname, 'public')))// routerconst special = &#123; 'daily_signin.js': '/daily_signin', 'fm_trash.js': '/fm_trash', 'personal_fm.js': '/personal_fm'&#125;fs.readdirSync(path.join(__dirname, '../module')).reverse().forEach(file =&gt; &#123; if(!(/\.js$/i.test(file))) return let route = (file in special) ? special[file] : '/' + file.replace(/\.js$/i, '').replace(/_/g, '/') let question = require(path.join(__dirname, '../module', file)) app.use(route, (req, res) =&gt; &#123; let query = Object.assign(&#123;&#125;, req.query, req.body, &#123;cookie: req.cookies&#125;) question(query, request) .then(answer =&gt; &#123; console.log('[OK]', decodeURIComponent(req.originalUrl)) res.append('Set-Cookie', answer.cookie) res.status(answer.status).send(answer.body) &#125;) .catch(answer =&gt; &#123; console.log(answer) console.log('[ERR]', decodeURIComponent(req.originalUrl)) if(answer.body.code =='301') answer.body.msg = '需要登录' res.append('Set-Cookie', answer.cookie) res.status(answer.status).send(answer.body) &#125;) &#125;)&#125;)const port = 3000 //在这里修改端口号app.server = app.listen(port, () =&gt; &#123; console.log(`server running @ http://localhost:$&#123;port&#125;`)&#125;)module.exports = app 20190201更新： 我将网易云音乐API node服务放在了我的服务器上，所以我这里直接使用我的服务器地址。 &lt;font color=#ff0000&gt;推荐为网易云API单独启动一个node服务，然后通过pm2进行管理。&lt;/font&gt; 启动electron-vue的node服务 1yarn dev //或者 npm run dev 此时控制台应打印出 稍等一会你会看到一个electron应用自动启动，说明node服务正式配置完毕。 四、electron服务配置反向代理 因为在electron-vue中需要用到网易云音乐API服务器的接口，但是网易云音乐API服务器端口为3000（或许你自定了一个端口），如果直接调用，会报跨域的错误，提示404 此时需要在electron-vue的.electron-vue/dev-runner.js中的electron服务中配置一个代理： 1234567891011121314151617181920212223242526272829/*--------------- electron-vue的node服务 -----------------*/function startRenderer () &#123; return new Promise((resolve, reject) =&gt; &#123; ...... const server = new WebpackDevServer( compiler, &#123; contentBase: path.join(__dirname, '../'), quiet: true, before (app, ctx) &#123; app.use(hotMiddleware) ctx.middleware.waitUntilValid(() =&gt; &#123; resolve() &#125;) &#125;, /*---- 以下是添加的代理设置 ----*/ proxy: &#123; "/api": &#123; target: 'http://localhost:3000', //指向网易云音乐API nodejs 服务器地址 //也可以使用你自己的服务器地址，但是方法同理 pathRewrite: &#123;'^/api' : ''&#125;, changeOrigin: true &#125; &#125; /*---- 代理设置到此结束 ----*/ &#125; ) &#125;｝---- 三、遇到的问题及解决方案 问题：在使用tray设置托盘的时候，在dev环境下能正常运行，但是打包成.exe文件之后提示icon错误。 原因：需要引入electron中的nativeImage模块，将icon转换成原生的图片。 解决方案： 原代码： 1tray = new Tray(`file://$&#123;__dirname&#125;/build/icon.ico`); 修改之后： 1234const &#123; Tray, nativeImage &#125; = require('electron');const iconPath = path.join(__dirname, 'build/icon.ico');mainWindow.tray = new Tray(nativeImage.createFromPath(iconPath)); 问题：在electron-vue中的页面里使用vuex报错，提示undefind。 原因：在electron-vue中为了实现多窗口之间能共享vuex的数据，引入了一个vuex-electron的插件，修改了vuex的配置方式。 解决方案： 按照`vuex-electron`的方式设置vuex，在`src/renderer/store/modules`中新建一个`NewStore.js`，并在该文件内编写`state`、`mutations`、`actions` 1234567891011121314151617const state = &#123; // your state code&#125;const mutations = &#123; // your mutations code&#125;const actions = &#123; // your actions code&#125;export default &#123; state, mutations, actions&#125;]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>网易云音乐</tag>
        <tag>electron-vue</tag>
        <tag>vue</tag>
        <tag>个人项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2019%2F02%2F26%2FGitStudy%2Fgit-study-1%2F</url>
    <content type="text"><![CDATA[使用git过程中的经验整理 因为最近在用git添加多个sshkey的时候报错了，使用ssh -V github.com的时候提示key不存在，在不存在的网站(google.com)中找到了解决方案，然后想了想，决定开一个blog专门记录使用git的时候出现的问题以及对应的解决方案。 一、添加多个sshkey 首先执行命令生成第一个git仓库的sshkey 1ssh-keygen -t rsa -C &quot;first-email@address.com&quot; 再次执行命令生成第二个git仓库的sshkey 1ssh-keygen -t rsa -C &quot;secound-email@address.com&quot; 注意，在生成不同的sshkey的时候记得给每个sshkey起不同的名字。 修改git配置 这一个操作有两个方法，一个是最常用的方法，也是随便搜索都能找到的方法： 方法1：在~/.ssh目录下新建一个config文件 1234567891011# first-websiteHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa# second-websiteHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 方法2：该方法是否规范我不太确定，但是这么做是修改了git里ssh的配置 修改git目录下的git/etc/ssh/ssh_config文件，在文件的最下面添加连接仓库用到的sshkey文件 12345678......# Added by git-extra# 在下方添加我们需要通过ssh连接的git仓库对应的sshkey文件IdentityFile ~/.ssh/github_id_rsaIdentityFile ~/.ssh/gitlab_id_rsaCiphers +aes128-cbc,3des-cbc,aes256-cbc,aes192-cbc 然后重启git 之后再连接不同的git仓库就能顺利的连接了]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue大转盘组件]]></title>
    <url>%2F2019%2F02%2F26%2Fcomponents%2FLotteryComponent%2FLottery%2F</url>
    <content type="text"><![CDATA[这是一个大转盘抽奖组件，可以自定义盘面，包括颜色、字体、图片等内容。 感谢@木子七大佬的大转盘文章这里是连接，在之后的使用中发现不能设置奖品并将奖品转动到对应的扇形盘面上，对此我进行了修改，使其可以在vue中正常使用，可能修改的并不好，希望各位指出。 实现过程我就不再重复编辑了，木子七大佬的文章中以及他的github中对大转盘的实现有详细的描述以及代码实现。在此我只对我改进的部分代码进行示例以及解释。 一、解决大转盘清晰度 方案1：该方案出自@boluobanana的简书文章，非常感谢大佬。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Writes an image into a canvas taking into * account the backing store pixel ratio and * the device pixel ratio. * * @author Paul Lewis * @param &#123;Object&#125; opts The params for drawing an image to the canvas*/function drawImage(opts) &#123; if(!opts.canvas) &#123; throw("A canvas is required"); &#125; if(!opts.image) &#123; throw("Image is required"); &#125; // get the canvas and context var canvas = opts.canvas, context = canvas.getContext('2d'), image = opts.image, // now default all the dimension info srcx = opts.srcx || 0, srcy = opts.srcy || 0, srcw = opts.srcw || image.naturalWidth, srch = opts.srch || image.naturalHeight, desx = opts.desx || srcx, desy = opts.desy || srcy, desw = opts.desw || srcw, desh = opts.desh || srch, auto = opts.auto, // finally query the various pixel ratios devicePixelRatio = window.devicePixelRatio || 1, // backingStoreRatio此属性已被弃用 // backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1, // ratio = devicePixelRatio / backingStoreRatio; ratio = devicePixelRatio; // ensure we have a value set for auto. // If auto is set to false then we // will simply not upscale the canvas // and the default behaviour will be maintained if (typeof auto === 'undefined') &#123; auto = true; &#125; // upscale the canvas if the two ratios don't match // if (auto &amp;&amp; devicePixelRatio !== backingStoreRatio) &#123; if (auto &amp;&amp; devicePixelRatio) &#123; var oldWidth = canvas.width; var oldHeight = canvas.height; canvas.width = oldWidth * ratio; canvas.height = oldHeight * ratio; canvas.style.width = oldWidth + 'px'; canvas.style.height = oldHeight + 'px'; // now scale the context to counter // the fact that we've manually scaled // our canvas element context.scale(ratio, ratio); &#125; context.drawImage(pic, srcx, srcy, srcw, srch, desx, desy, desw, desh);&#125; 方案2：精简版代码 123456789101112131415161718192021let getPixelRatio = function (context) &#123; let backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1; return (window.devicePixelRatio || 1) / backingStore;&#125;;let ratio = getPixelRatio(context);let fontSize = document.getElementsByTagName("html")[0].style.fontSize.split("px")[0] || 100;canvas.style.width = canvas.width / fontSize + 'rem';canvas.style.height = canvas.height / fontSize + 'rem';canvas.width = canvas.width * ratio;canvas.height = canvas.height * ratio;// 放大倍数context.scale(ratio, ratio); 以上两个方案均能解决canvas在高分屏上绘制出现模糊的问题。 二、预加载盘面图片在canvas中有多种加载图片的方式，常用的有以下两种方式： 方式一：通过new Image()声明一个Image对象，并通过src设置图片路径 12345678// 声明一个Image()对象let img = new Image();// 设置Image对象的srcimg.src = "path/icon.png";// 在canvas中绘制图片ctx.drawImage(img, 0, 0, imageWidth, imageHeight); 方式二：首先通过&lt;img&gt;标签向html中插入一张图片，然后使用getElementById获取这个img元素，再执行绘图 1234&lt;!-- 在html页面中插入img元素 --&gt;&lt;body&gt; &lt;img id="img" style="display:none;" src="path/icon.png"&gt;&lt;/body&gt; 12345// 获取页面中的html元素let img = document.getElementById("img");// 在canvas中绘制图片ctx.drawImage(img, 0, 0, imageWidth, imageHeight); 讲到这里，有必要提一下这里碰到的一个问题，通过方式一在canvas中绘图一张图片时，发现并不能成功绘制，而通过方式二绘制的时候却能正常显示。 这是因为canvas在绘制图片的时候需要 等图片加载成功之后才可以进行绘制，drawImage()这个方法在图片未加载完成的时候是不会被调用的，所以导致了绘图失败。 我们该如何解决这个问题呢？我百度并尝试了多种方式，最后总结了三种方法用于解决这个问题： 方法一：&lt;img&gt;标签和window.onload配合使用 12&lt;!-- html代码 --&gt;&lt;img src=""&gt; 1234// JavaScript代码window.onload = function() &#123; context.drawImage();&#125; 或者在后期插入标签： 1234let img = document.createElement("img");img.src = "path";document.body.appendChild(img);context.drawImage(img, 0, 0, width, height); 方法二：使用定时器setTimeout()异步实现 123setTimeout(function() &#123; context.drawImage(img, 0, 0, width, height);&#125;, 10) 延迟时间需要根据不同的情况设定，所以用定时器去解决这个方案是有弊端的，不能保证定时器时间到了之后图片能正常加载，若出现网络较差的情况还是会遇到无法加载的情况。 方式三：使用img.onload监听图片加载结束 12345img.onload = function()&#123; console.log('图片加载成功'); console.log(this); context.drawImage(img, 0, 0, width, height);&#125; 使用onload监听img的加载，加载结束之后再执行图片的绘制，目前最靠谱的方式就是这个。 需要注意的是onload是一个异步任务。 我使用的是img标签加onload监听图片加载的方式 12&lt;!-- html代码 --&gt;&lt;img id="img" src="path"&gt; 1234567// JavaScript代码let img = document.getElementById("img"); //获取imgimg.onload = function() &#123; //监听img是否加载结束 console.log('图片加载成功'); console.log(this); context.drawImage(img, 0, 0, width, height); //绘制图片&#125; 三、大转盘盘面相关修改 去掉@木子七大佬原来的触发按钮以及使用canvas绘制的指针，并添加一个透明的div用于给用户”点击”。 123456789101112131415161718192021222324&lt;template&gt; &lt;div class="canvas-main"&gt; &lt;div id="spin_button"&gt;&lt;/div&gt; &lt;!-- 这是一个透明的“点击”按钮 --&gt; &lt;div id="spin_button_mask" @click="clickBtn"&gt;&lt;/div&gt; &lt;canvas id="canvas" width="300" height="300"&gt; &lt;/canvas&gt; &lt;div style="display: none"&gt; &lt;img id="prize1" src="prize01.png" width="100"&gt; &lt;img id="prize2" src="prize02.png" width="100"&gt; &lt;img id="prize3" src="prize03.png" width="100"&gt; &lt;img id="prize4" src="prize04.png" width="100"&gt; &lt;img id="prize5" src="prize05.png" width="100"&gt; &lt;img id="prize6" src="prize06.png" width="100"&gt; &lt;img id="prize7" src="prize07.png" width="100"&gt; &lt;img id="pointer-red" src="red-pointer.png" width="158"&gt; &lt;img id="pointer-gray" src="gray-pointer.png" width="158"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 在&lt;canvas&gt;标签中添加文字说明，用于当浏览器不兼容canvas标签的时候的提示 --&gt; 加载转盘奖品图片和按钮图片 123456789101112131415161718192021222324252627282930313233343536373839// ---- 加载所有图片，目前是写死用的，可以删除// 因为onload是异步操作，故每加载一张图片则令imgFlag加一，当imgFlag === 9的时候说明9张图片加载完毕， 此时可以开始绘制转盘// 加载按钮图片let btn_img_red = document.getElementById(`pointer-red`);let btn_img_gray = document.getElementById(`pointer-gray`);let imgFlag = 0;let imgs = []; //此数组用于暂存奖品图片awards.forEach((item, index) =&gt; &#123; //遍历奖品数组并加载奖品图片 if (item.img) &#123; let imgObj = document.getElementById(`prize$&#123;index + 1&#125;`); imgs.push(imgObj); imgObj.onload = function () &#123; imgFlag++; if (imgFlag &gt;= 9) &#123; //判断一共9张图片是否全部加载完毕 console.log("开始绘制盘面"); drawRouletteWheel(); &#125; &#125; &#125; else &#123; imgs.push(null) &#125;&#125;);btn_img_red.onload = function () &#123; imgFlag++; if (imgFlag &gt;= 9) &#123; //判断一共9张图片是否全部加载完毕 console.log("开始绘制盘面"); drawRouletteWheel(); &#125;&#125;;btn_img_gray.onload = function () &#123; imgFlag++; if (imgFlag &gt;= 9) &#123; //判断一共9张图片是否全部加载完毕 console.log("开始绘制盘面"); drawRouletteWheel(); &#125;&#125;; 绘制盘面相关内容，如奖品名称、奖品价格、奖品略缩图等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/*** 绘制转盘*/function drawRouletteWheel() &#123; // ----- ① 清空页面元素，用于逐帧动画 context.clearRect(0, 0, canvas.width, canvas.height); // ----- for (let i = 0; i &lt; awards.length; i++) &#123; let _startRadian = startRadian + awardRadian * i, // 每一个奖项所占的起始弧度 _endRadian = _startRadian + awardRadian; // 每一个奖项的终止弧度 // ----- ② 使用非零环绕原则，绘制圆盘 context.save(); if (i % 2 === 0) &#123; context.fillStyle = "#ffedee" &#125; else &#123; context.fillStyle = "#ffffff" &#125; context.beginPath(); context.arc(canvas.width / 2 / ratio, canvas.height / 2 / ratio, OUTSIDE_RADIUAS, _startRadian, _endRadian, false); context.arc(canvas.width / 2 / ratio, canvas.height / 2 / ratio, INSIDE_RADIUAS, _endRadian, _startRadian, true); context.fill(); context.restore(); // ----- // ----- ③ 绘制文字 context.save(); if (awards[i].img) &#123; context.font = _this.fontSize + "px bold"; &#125; else &#123; context.font = _this.fontSize + 4 + "px bold"; &#125; context.fillStyle = "#5e5d5d"; context.translate( CENTER_X + Math.cos(_startRadian + awardRadian / 2) * TEXT_RADIUAS, CENTER_Y + Math.sin(_startRadian + awardRadian / 2) * TEXT_RADIUAS ); context.rotate(_startRadian + awardRadian / 2 + Math.PI / 2); // 绘制图片，默认奖品在偶数位 if (awards[i].img &amp;&amp; imgs[i]) &#123; // context.drawImage(bgImg, -context.measureText(awards[i].name).width / 2,0,50,50); context.drawImage(imgs[i], -25, -65, 50, 50); &#125; // 名称 当奖品带有图片的时候调整字体绘制位置和大小等相关属性 if (awards[i].img) &#123; if (awards[i].AwardName.length &gt; 10) &#123; context.fillText(awards[i].AwardName, -context.measureText(awards[i].AwardName).width / 2, -5 * (awards[i].AwardName.length - 10)); &#125; else &#123; context.fillText(awards[i].AwardName, -context.measureText(awards[i].AwardName).width / 2, 0); &#125; &#125; else &#123; context.fillText(awards[i].AwardName, -context.measureText(awards[i].AwardName).width / 2, -20); &#125; // 价格 if (awards[i].MdseAmount) &#123; context.fillText(awards[i].MdseAmount, -context.measureText(awards[i].MdseAmount).width / 2, 16); &#125; context.restore(); // ----- &#125; // -----④绘制按钮 if (!_this.disabled) &#123; //disabled是控制"开始旋转"按钮是否可以点击的参数，当可以点击的时候绘制红色的按钮，当不可点击的时候绘制灰色的按钮 context.drawImage(btn_img_red, canvas.width / 2 / ratio - btn_img_red.width / 2 / ratio * 1.5, canvas.height / 2 / ratio - btn_img_red.height / 2 / ratio * 1.5, btn_img_red.width / ratio * 1.5, btn_img_red.height / ratio * 1.5) &#125; else &#123; context.drawImage(btn_img_gray, canvas.width / 2 / ratio - btn_img_gray.width / 2 / ratio * 1.5, canvas.height / 2 / ratio - btn_img_gray.height / 2.5 / ratio * 1.5, btn_img_gray.width / ratio * 1.5, btn_img_gray.height / ratio * 1.25) &#125; // ----- // ----- ④ 绘制指针 因指针使用自定义的按钮，并绘制在图片上，故原绘制指针的方法删除 // context.save(); // context.beginPath(); // context.moveTo(CENTER_X, CENTER_Y - OUTSIDE_RADIUAS + 8); // context.lineTo(CENTER_X - 10, CENTER_Y - OUTSIDE_RADIUAS); // context.lineTo(CENTER_X - 4, CENTER_Y - OUTSIDE_RADIUAS); // context.lineTo(CENTER_X - 4, CENTER_Y - OUTSIDE_RADIUAS - 10); // context.lineTo(CENTER_X + 4, CENTER_Y - OUTSIDE_RADIUAS - 10); // context.lineTo(CENTER_X + 4, CENTER_Y - OUTSIDE_RADIUAS); // context.lineTo(CENTER_X + 10, CENTER_Y - OUTSIDE_RADIUAS); // context.closePath(); // context.fill(); // context.restore(); // -----&#125; 开始旋转触发方法修改 123456789101112131415161718192021/*** 开始旋转*/function rotateWheel() &#123; // 当 当前时间 大于 总时间，停止旋转，并返回当前值 spinningTime += 20; if (spinningTime &gt;= spinTotalTime) &#123; _this.disabled = false; _this.$emit('end'); //当转盘停止转动的时候触发end回调 drawRouletteWheel(); //当结束的时候重新绘制一次转盘，保证按钮是可转动的状态对应的按钮 return &#125; else &#123; _this.disabled = true; &#125; let _spinningChange = (spinningChange - easeOut(spinningTime, 0, spinningChange, spinTotalTime)) * (Math.PI / 180); startRadian += _spinningChange; drawRouletteWheel(); window.requestAnimationFrame(rotateWheel);&#125; 监听点击事件，开始旋转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071_this.$refs["spin_button"].addEventListener("click", () =&gt; &#123; if (!_this.disable) &#123; //控制抽奖次数的参数 if (!_this.disabled) &#123; //控制是否重复点击的参数 // 获取奖品在数组中的下标 if (getIndex() !== false) &#123; listIndex = getIndex(); &#125; else &#123; console.error("请确定中奖奖品是否在奖品列表中"); _this.clear = false; return &#125; function getIndex() &#123; let i = null; let notWonIndex = null; _this.list.forEach((item, index) =&gt; &#123; if (item.AwardNo) &#123; // if (_this.prize === item.AwardNo) &#123; // i = index; // &#125; else if (item.AwardNo === "MDSE999999999999999") &#123; // notWonIndex = index; // &#125; if (_this.prize === item.AwardNo) &#123; i = index; &#125; else &#123; notWonIndex = index; &#125; &#125; else &#123; console.warn("请确认奖品编号字段是否存在") &#125; &#125;); if (!notWonIndex) &#123; console.warn("奖品编号不存在，自动设置为谢谢参与") &#125; if (i !== null) &#123; return i; &#125; else &#123; return notWonIndex; &#125; &#125; // 获取中奖奖品旋转的起始角度 turnStartRadian = awardRadian * listIndex; // 获取中奖奖品的起始角度 turnEndRadian = awardRadian * listIndex + awardRadian; // 获取中奖奖品的结束角度 spinningTime = 0; // 初始化当前时间 startRadian = 0; // 初始化弧度 spinTotalTime = 5 * 1000; // 随机定义一个时间总量 prizeAngle = awardRadian * 180 / Math.PI * Math.floor(Math.random() * 10 + 1) / 10; //该参数是确定奖品的对应角度(360°内) if (prizeAngle &gt; 0.7 * (360 / _this.list.length)) &#123; prizeAngle = 0.7 * (360 / _this.list.length) &#125; else if (prizeAngle &lt; 0.3 * (360 / _this.list.length)) &#123; prizeAngle = 0.3 * (360 / _this.list.length) &#125; spinningChange = (turnStartRadian * 180 / Math.PI - 90 * (listIndex + 1) % 360 - prizeAngle + 360 * turns) / 124.5; //根据相应的角度算出大转盘的旋转速率，保证转盘停止转动的时候能落在我们想落在的位置 rotateWheel(); &#125; else &#123; console.log('请勿重复点击') &#125; &#125; else &#123; console.log('今日抽奖次数已用完') &#125;&#125;); 以上的修改均在vue的mounted生命周期之内进行，此时需要进行相应的修改，整个vue组件大概结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name: "Lottery",props: &#123; // 获取数组 disable: &#123; type: Boolean, default: false &#125;, // 盘面奖品list list: &#123; type: Array, default: (val) =&gt; &#123; if (!val || val.length === 0) &#123; console.error("请确认转盘盘面奖项列表") &#125; &#125; &#125;, // 设置中奖奖项 prize: &#123; type: String, default: null &#125;, // 设置奖品字体 fontSize: &#123; type: Number, default: 16 &#125;, // 设置旋转圈数 turns: &#123; type: Number, default: 5 &#125;, // 控制转盘转动 run: &#123; type: Boolean, default: false &#125;&#125;,data() &#123; return &#123; disabled: false, //控制大转盘是否可以点击 &#125;&#125;,mounted() &#123; this.$nextTick(() =&gt; &#123; let _this = this; //将vue的this值赋予_this，目的是防止之后this被污染导致获取不到正确的值 // ......对应的代码 &#125;)&#125;,watch: &#123; run(val) &#123; //监听run的变化，当run变化的时候触发spin_button的click事件 if (val &amp;&amp; !this.disabled) &#123; this.$refs["spin_button"].click(); &#125; &#125;&#125;,methods: &#123; // 点击按钮遮罩 clickBtn() &#123; if (!this.run &amp;&amp; !this.disabled) &#123; console.log("开始旋转"); this.$emit('start') &#125; else &#123; console.error("请勿重复点击") &#125; &#125;,&#125; 四、效果图 本文部分内容转载自@木子七的大转盘文章]]></content>
      <categories>
        <category>vue组件</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象学习]]></title>
    <url>%2F2019%2F02%2F26%2FJavaScript%2FPromiseStudy%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise学习一、回调函数的问题学过 JavaScript 的人都应该清楚一件事，JavaScript语言的一大特点就是单线程，目的是为了提高效率。因此在 JavaScript 中回调函数不会立即执行，而是由事件轮询去检测事件是否执行完毕，当执行完毕并且有结果之后，将执行结果放入回调函数中，然后将回调函数添加到事件队列中等待被执行。 在这里会有一些关于回调函数的问题： “回调地狱”：即“洋葱模型”，回调函数作为异步函数的参数，会形成多级的嵌套，当嵌套级数过多时，代码逻辑会变得混乱，无法将错误的捕捉和处理这个简单的工作做好，只能在回调函数的内部通过try{}...catch(){}捕获并处理异常。 回调函数的执行方式不符合自然语言的线性思维方式，不易理解。 控制反转，即控制权不在我们手中，而是在其他人的代码中。例如该异步函数是第三方库，当我们把回调函数传给第三方库的时候，我们并不能知道我们的异步函数在第三方库里做了什么，在调用回调函数之前做了什么。 解决回调函数的问题有很多种方法，其中比较好的一种方式就是使用 Promise 对象。 二、什么是PromisePromise 是目前在 JavaScript 异步编程中比较流行的解决方案之一，Promise 用于表示一个异步操作的最终状态（完成或者失败），并且可以链式的处理异步请求（.then()方法），很好的处理异常问题，是解决回调地狱的良好方案之一。MDN对 Promise 的解释如下： Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise对象。 三、Promise 的状态Promise 一共包含有三种状态： pending：初始状态，既不是成功状态，也不是失败状态，在网上多数人称为等待中状态。 fulfilled：成功状态，意味着操作成功完成。 rejected：失败状态，意味着操作失败。 Promise 无论如何都会返回一个结果，不是成功，就是失败。并且 Promise 的设计具有原子性，即当状态从pending状态转变为fulfilled状态或者rejected状态后，将不能改变。 在pending状态中，Promise 可能触发fulfilled状态并将成功结果传递给相应的状态处理方法，也可能触发rejected状态并将失败信息返回。 (图片来自@MDN) 四、Promise 的原理从本文前面的内容中可知 Promise 有三个状态，并且会返回一个成功或者失败的结果。 (图来自于https://juejin.im/post/5c724f14518825626b76f6d5) 12345678910111213141516171819202122232425262728293031var promise = new Promise((resolve, reject) =&gt; &#123; console.log("Promise构造器执行"); setTimeout(() =&gt; &#123; if (true) &#123; resolve("成功"); &#125; else &#123; reject("失败"); &#125; &#125;, 1000)&#125;)promise.then((result) =&gt; &#123; console.log(result); return 1; // return Promise.resolve(1); // 返回一个决议为成功的 Promise 实例 // return Promise.reject("error"); // 返回一个决议为拒绝的 Promise 实例&#125;).then((result) =&gt; &#123; // .then() 方法会返回一个 Promise, 完成调用的参数为前一个 Promise 的返回值或者决议值。 console.log(result); throw new Error("抛出错误"); // 抛出错误是隐式拒绝&#125;).catch((error) =&gt; &#123; console.log(error);&#125;).then(() =&gt; &#123; // Continue to do other things&#125;).finally(() =&gt; &#123; console.log("finally");&#125;) 五、Promise 的语法1new Promise( function(resolve, reject) &#123;...&#125; /* executor */ ); 参数： executor： executor函数带有resolve和reject两个参数。当 Promise 构造函数在执行时会立即调用executor函数，executor函数在 Promise 构造函数返回新建对象之前会被调用，并将resolve和reject两个函数作为参数传递给executor函数。在executor函数内部通常会执行一些异步操作，并在异步操作完成时调用resolve函数或者reject函数将 promise 的状态修改为fulfilled(成功)或者rejected(失败) 只要在executor函数中抛出一个错误，promise 的状态就会转换为rejected，此时executor函数的返回值将会被忽略。 六、Promise 的属性 Promise.length： Promise 的 length 属性，其值始终为 1，即构造器参数的数目。 Promise.prototype： Promise 构造器的原型。 七、Promise 的方法 Promise.all(iterable)： 当 promise 对象中 iterable 参数对象里所有的 promise 对象都成功执行的时候触发的一个方法，若 iterable 中有任何一个 promise 对象执行失败则会立即触发该 promise 对象的失败。该方法在触发成功状态之后，会将 iterable 参数里所有 promise 对象返回值放入一个数组中并将该数组作为成功回调的返回值，该数组中各个 promise 对象的返回值顺序与 iterable 的顺序保持一致。如果触发了失败状态，则该方法会将第一个触发失败状态的 promise 对象的错误信息作为它的错误信息返回。该方法常用于处理多个 promise 对象的状态合集。 Promise.race(iterable)： iterable 参数中只要有一个 promise 对象触发了额成功状态或者失败状态，就会将该 promise 对象的值作为它的返回值。 Promise.reject(reason)： 返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法。 Promise.resolve(value)： 返回一个状态由给定 value 决定的 Promise 对象。如果该值是一个 Promise 对象，则直接返回该对象；如果该值是 thenable (即，带有.then()方法的对象)，返回的 Promise 对象的最终状态由.then()方法执行决定；否则的话(该 value 为空，基本类型或者不带.then()方法的对象)，返回的 Promise 对象状态为fulfilled，并且将该 value 传递给对应的.then()方法。通常而言，如果你不知道一个值是否是 Promise 对象，使用Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。 八、Promise 的原型 属性： Promise.prototype.construtor： 返回被创建的实例函数. 默认为 Promise 函数。 方法： Promise.prototype.catch(onRejected)： 当.then()方法中发生错误时，.catch()方法会捕获并处理错误，并将一个rejection(拒绝)回调到当前的 promise，然后返回一个新的 promise。新的 promise 以.catch()的返回值来 resolve。 Promise.prototype.then(onFulfilled, onRejected)： 在当前的 promise 中添加fulfilled(解决)回调和rejuection(拒绝)回调，并以回调的返回值来 resolve。 Promise.prototype.finally(onFinally)： 无论 promise 的状态是处于fulfilled(成功)状态还是rejected(失败)状态，都会调用的一个方法，并且在该回调中返回一个新的 promise 对象。 九、Promise 的优势 链式调用： Promise 在使用后会返回一个新的 Promise 便于我们传递状态参数。同时因为其链式的写法更接近于同步写法，更加符合线性思维。 错误捕捉： Promise 能够为链式异步调用提供错误处理。 控制权的再次反转： 第三方提供的异步函数我们无法保证回调函数如何被执行，但是通过 Promise 我们能够保证 resolve 只会执行一次，并且 Promise 始终以异步的形式执行。 解决未决议和并行嵌套的问题： Promise 的Promise.all(iterable)方法和Promise.race(iterable)方法可以用于解决 Promise 始终未决议和并行 Promise 嵌套的问题。 十、Promise对象的不足 每个.then()方法都是一个独立的作用域： 当我们加入多个.then()方法时，会创建多个独立的作用域，要想解决作用域的数据共享问题需要在外层包裹一层函数作用域实现闭包。 .then()无法取消： .catch()能捕获并处理 Promise 链中任意一个.then()方法中的错误，但是不会中断整个 Promise 链的执行。 无法得知进度： Promise 只会从pending状态转变为fullfilled状态或者rejected状态，所以我们无法得知pending阶段的进度。 十一、应用 Promise 的简单例子123456789101112131415161718192021222324252627282930313233343536// 使用 Promise 对ajax进行封装function fetch(method, url, data)&#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); var method = method || "GET"; var data = data || null; xhr.open(method, url, true); xhr.onreadystatechange = function() &#123; if(xhr.status === 200 &amp;&amp; xhr.readyState === 4)&#123; resolve(xhr.responseText); &#125; else &#123; reject(xhr.responseText); &#125; &#125; xhr.send(data); &#125;)&#125;// 使用fetch("GET", "/api", null).then(result =&gt; &#123; console.log(result);&#125;)// 封装 nodejs error first 风格回调function readFile(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url,'utf8', (err, data) =&gt; &#123; if(err) &#123; reject(err); return; &#125; resolve(data) &#125;) &#125;)&#125; 参考资料（排名不分先后顺序） @南波的《JS异步编程之Promise》 @南波的《JS异步编程之callback》 @蟹丸的《前端异步技术之Promise》 MDN的Promise文档]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
