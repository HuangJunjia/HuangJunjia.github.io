<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何使用canvas获取一张图片的主色调以及通过欧式距离计算最接近的颜色]]></title>
    <url>%2F2019%2F05%2F17%2FJavaScript%2Fcanvas%2FCanvasGetMainColor%2F</url>
    <content type="text"><![CDATA[写在开头最近做的一个项目中，有一个需求，就是聊天对话框能根据用户的头像Logo或者聊天框的背景图的主色调修改颜色，或者是替换成预设好的rgba颜色中的一种。 一张图片的主色调无非就是在这张图片中出现次数最多的颜色，那我们该如何获取一张图片中的所有像素数据并且计算出重复次数最多的颜色呢？接下来，我们有请我们最佳助手——canvas！ 使用Canvas绘制一张图片估计在这里，会有人问，为什么本文内容是讲获取主色调，却先写如何使用canvas绘制图片？这是因为通过canvas绘制出来的图片都会在canvas的ImageData对象中储存真实的像素数据，我们需要通过获取所有的像素数据去计算出颜色的重复次数。通过对获得的像素颜色数据的数组进行重复次数计算，就能得到重复次数最多的颜色了。 首先，我们通过JavaScript创建一个HTMLImageElement对象： 123const img = new Image(); // 创建一个&lt;img&gt;元素img.src = 'myImage.png'; // 设置图片源地址// img.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==' // 使用Base64编码的字符串也是可以的，我比较喜欢使用这种，因为不需要通过服务器 接下来，我们在图片装载完之后绘制到canvas中： 1234567const canvas = document.createElement("canvas");const context = canvas.getContext("2d");const img = new Image();img.src = 'myImage.png';img.onload = () =&gt; &#123; context.drawImage(img, 0, 0); // 使用canvas的api drawImage()将图片绘制到canvas中&#125; 到此，我们就已经在canvas中绘制好了一张图片了。 获取图片所有的像素点的rgba在上文中我们已经在canvas中绘制了一张图片，接下来我们需要通过canvas API: getImageData()获取canvas中包含画布场景像素数据的ImageData对象： 1const ctxImageData = context.getImageData(0, 0, canvas.width, canvas.height).data; 这个时候我们可以获取到一个像素数组里面的像素数据， 然而这个却不是很直观的rgba的值，我们需要做一个转换处理 1234let colorList = [];for (let i = 0; i &lt; ctxImageData.length; i += 4) &#123; colorList.push(`rgba($&#123;data[i]&#125;, $&#123;data[i + 1]&#125;, $&#123;data[i + 2]&#125;, $&#123;(data[i + 3] / 255)&#125;)`)&#125; 这下，是不是就是我们想看到的最直观的rgba数据了？然而，在这些数据中也有一些值是我们不需要的，因为有的像素的a值是0，即这个像素是透明的，我们肉眼其实是看不到这些像素的，那我们在获取的时候就应该排除掉这些a值为0的像素。 12345for (let i = 0; i &lt; data.length; i += 4) &#123; if (data[i + 3] !== 0) &#123; colorList.push(`rgba($&#123;data[i]&#125;, $&#123;data[i + 1]&#125;, $&#123;data[i + 2]&#125;, $&#123;(data[i + 3] / 255)&#125;)`) &#125;&#125; 最终我们得到的数组中就没有透明度为0的rgba值了。 开始寻找我们的出现次数最多的颜色计算数组中某个rgba的值的出现次数，我们通过设置对象的属性来确保颜色只保存在一个属性中，并且重复出现时能够累加出现次数，接下来，我们修改之前的代码，把去重和累计添加进去： 12345678910// 使用reduce去重并计算重复次数let rgbaData = data.reduce((accumulator, currentValue, index) =&gt; &#123; if (index % 4 === 0) &#123; if (currentValue !== 0) &#123; let rgba = `rgba($&#123;data[index]&#125;, $&#123;data[index + 1]&#125;, $&#123;data[index + 2]&#125;, $&#123;(data[index + 3] / 255)&#125;)`; accumulator[rgba] = (accumulator[rgba] + 1) || 1; &#125; &#125; return accumulator;&#125;, &#123;&#125;); 接下来，我们获取value值最大的key值，这里我使用了一个笨方法，如果有好的方法或者建议麻烦在评论区留言，非常感谢~ 123456789101112let sortRepeatNumber = [...Object.values(rgbaData)].sort((v1, v2) =&gt; &#123; return v1 - v2&#125;);let color = "";for (let i in rgbaData) &#123; if (rgbaData[i] === sortRepeatNumber[sortRepeatNumber.length - 1]) &#123; color = i; break &#125;&#125; 到这里，我们就能拿到一张图片的主色调即出现次数最多的颜色了。 到此，获取图片主色调的方法结束，我们来看一下实际效果以及代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 获取一张图片的主色调 * @param &#123;string | ArrayBuffer&#125; image 服务器图片地址或者图片base64 * @return &#123;Promise&#125; rgba color * */function getMainColor(image) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; const canvas = document.createElement("canvas"); const img = new Image(); // 创建img元素 img.src = image; // 设置图片源地址 img.onload = function () &#123; let color = getImageColor(canvas, img); resolve(color) &#125;; &#125; catch (e) &#123; reject(e) &#125; &#125;); function getImageColor(canvas, img) &#123; const context = canvas.getContext("2d"); context.drawImage(img, 0, 0); // 获取像素数据 let data = context.getImageData(0, 0, canvas.width, canvas.height).data; let rgbaData = data.reduce((accumulator, currentValue, index) =&gt; &#123; if (index % 4 === 0) &#123; if (currentValue !== 0) &#123; let rgba = `rgba($&#123;data[index]&#125;, $&#123;data[index + 1]&#125;, $&#123;data[index + 2]&#125;, $&#123;(data[index + 3] / 255)&#125;)`; accumulator[rgba] = (accumulator[rgba] + 1) || 1; &#125; &#125; return accumulator; &#125;, &#123;&#125;); let sortRepeatNumber = [...Object.values(rgbaData)].sort((v1, v2) =&gt; &#123; return v1 - v2 &#125;); let color = ""; for (let i in rgbaData) &#123; if (rgbaData[i] === sortRepeatNumber[sortRepeatNumber.length - 1]) &#123; color = i; break &#125; &#125; let resultColor = color.match(/[0-9]\.?[0-9]*/g).map(Number); return &#123; r: resultColor[0], g: resultColor[1], b: resultColor[2], a: resultColor[3] &#125; &#125;&#125; 什么是颜色差异以及常用的算法还是因为项目需要（学习的动力是工作需要_(:зゝ∠)_），好了，回归正题，当时做完获取主色调之后，产品说需要根据获取到的主色调去匹配之前预设的四种主题颜色RED、BLUE、GREEN和YELLOW，然后使用与主色调最接近的预设主题色。好吧好吧，Baidu、Google、Wiki还有伟大的Stack Overflow走一遍，然后发现获取近似色的方法通常为通过计算颜色差异，或者叫做距离的大小，取最小值匹配到最相似的颜色，具体常用的方法有以下几种： 以下内容摘自Wiki百科—颜色差异条目 欧氏距离 很多日常使用的“颜色差异”，是直接通过在一个“设备无关”的色彩空间里，进行欧氏距离的计算得到的。给定一个RGB（红绿蓝）的色彩空间，最简单的差异计算方式就是在这个三维空间里求两个点间的距离： 如果还要简单一点，经常可以去掉平方根： 这样求得的距离可以用来比较两个颜色中哪一个更接近某个给定的颜色。如果把这些平方距离加在一起，会得到一组距离间的方差。 有不少人尝试将RGB三值加上权重，希望可以让得到的结果更加符合人类感官。一种做法是使用2、4、3： 对于0~255的数值，有一种近似是： 因为我接下来选择使用了最简单的欧氏距离来计算颜色差异，所以其他的方法我就不详细描述了，毕竟不是本文主要内容，感兴趣的朋友可以在Wiki百科—颜色差异条目中查看。 Delta E 国际照明委员会（CIE）称他们的度量标准为“ΔE*ab”（也作“ΔE”，另有“dE”、“_dE_”、“Delta E”）。其中，delta 是一个常用来表示“差异”的希腊字母，E表示Empfindung，也就是德文中的“感觉”。富有影响的赫尔曼·冯·亥姆霍兹和埃瓦尔德·赫林曾使用过它。 两个颜色之间的JND值，也就是有多大的ΔE*差距才能刚好被察觉，目前还没有定论。尽管并没有实践经验支持，’1.0’这个值经常被提到并用作JND。可是，1994年，Mahy et al研究并评估出了一个2.3ΔE的JND值。然而，支撑该理论的CIELAB色彩空间中，知觉的非均匀特性（换言之，有些颜色在改变时，人眼对其十分敏感，而有的就分辨得不太清楚）导致这种理论不太站得住脚。这使得CIE用了接下来的几年时间修缮他们的定义，最终产生了更完善的（据CIE）1994年和2000年的公式。这些非均匀特性很重要，因为人眼对某些特定的颜色更敏感。一个好用的度量方法，应该把这些因素都考虑在内，才能使“刚刚好能被察觉到的差异”这种提法有意义。不然的话，可能出现这样的情况：对于两组分别含有一对不同的颜色、同样适用某个ΔE值的颜色组，其中一组颜色的差异能被人眼觉察出来，另一组却不能。 L、a和b三个值（见下方公式）一般是介于(-1,1)之间的双精度数值。Lab图像在保存时，L被存储为无符号（即“不分正负”）8位元整数，a、b则被存储为有符号的8位元整数，以保持文件大小。 CIE76 1976年的这个色彩差异公式是首个用较为均匀的Lab空间计算色彩差异值的公式。Lab比RGB等空间在感官上均匀一点，所以得到的结果会更好。不过后来人们发现Lab色彩空间，尤其是在饱和度较高的区域里，并没有设计时预想的那么“感官上均匀”，所以几次更新了ΔE公式。CIE76公式会高估较为饱和的颜色之间的差异。 CIE94 在汽车喷漆行业里，人们测量了一堆人眼容差情况的数据。随着这些“应用特定”的数据的发布，人们将1976年的定义进行了进一步的发展，以更好地应对感知非均匀特性。该公式仍然采用的是Lab色彩空间。 CIEDE2000 鉴于1994年的公式并没有充分解决感知非均匀特性的问题，CIE再次修缮了定义，并加入了5个修订系数： 色调旋转项(RT)，用来应对常出问题的蓝色区域（色相角度275°左右） 中性色调补偿（对应LCh差异） 亮度补偿（SL） 色度补偿（SC） 色调补偿（SH） 通过JavaScript获取近似色即颜色差异最小值的颜色首先我们需要设置好我们的预设色，我们分别设置RED、BLUE、YELLOW和GREEN： 1234567891011121314151617181920const RED = &#123; r: 189, g: 62, b: 65&#125;;const BLUE = &#123; r: 0, g: 94, b: 197&#125;;const YELLOW = &#123; r: 255, g: 141, b: 0&#125;;const GREEN = &#123; r: 0, g: 139, b: 36&#125;; 因为我在上文中选择了欧氏距离，所以接下来的代码将使用转换过后的欧氏距离算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 欧氏距离算法 * @method getEuclideanDistance * @param &#123;Number&#125; red 0-255 * @param &#123;Number&#125; green 0-255 * @param &#123;Number&#125; blue 0-255 * @return &#123;String&#125; red, blue, yellow, green * */function getEuclideanDistance(red, green, blue) &#123; // 欧氏距离算法 let r1 = (red + RED.r) / 2; let r2 = (red + BLUE.r) / 2; let r3 = (red + YELLOW.r) / 2; let r4 = (red + GREEN.r) / 2; let varianceR1 = red - RED.r; let varianceR2 = red - BLUE.r; let varianceR3 = red - YELLOW.r; let varianceR4 = red - GREEN.r; let varianceG1 = green - RED.g; let varianceG2 = green - BLUE.g; let varianceG3 = green - YELLOW.g; let varianceG4 = green - GREEN.g; let varianceB1 = blue - RED.b; let varianceB2 = blue - BLUE.b; let varianceB3 = blue - YELLOW.b; let varianceB4 = blue - GREEN.b; let varianceC1 = Math.sqrt((2 + r1 / 256) * Math.pow(varianceR1, 2) + 4 * Math.pow(varianceG1, 2) + (2 + (255 - r1) / 256) * Math.pow(varianceB1, 2)); let varianceC2 = Math.sqrt((2 + r2 / 256) * Math.pow(varianceR2, 2) + 4 * Math.pow(varianceG2, 2) + (2 + (255 - r2) / 256) * Math.pow(varianceB2, 2)); let varianceC3 = Math.sqrt((2 + r3 / 256) * Math.pow(varianceR3, 2) + 4 * Math.pow(varianceG3, 2) + (2 + (255 - r3) / 256) * Math.pow(varianceB3, 2)); let varianceC4 = Math.sqrt((2 + r4 / 256) * Math.pow(varianceR4, 2) + 4 * Math.pow(varianceG4, 2) + (2 + (255 - r4) / 256) * Math.pow(varianceB4, 2)); let list = [ &#123;variance: varianceC1, color: "red"&#125;, &#123;variance: varianceC2, color: "blue"&#125;, &#123;variance: varianceC3, color: "yellow"&#125;, &#123;variance: varianceC4, color: "green"&#125; ]; list.sort((v1, v2) =&gt; &#123; return v1.variance - v2.variance &#125;); return list[0]&#125; 来看看实际效果吧： 到此，我们学习了如何使用canvas获取一张图片的主色调以及使用欧氏距离算法计算并获得近似色的方法，大家下次见~]]></content>
      <categories>
        <category>JavaScript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS自定义属性var()的那些事儿~]]></title>
    <url>%2F2019%2F05%2F16%2FCSSStudy%2FCSSVariable%2F</url>
    <content type="text"><![CDATA[写在前面在这里，我先给var()正个名，我们平常都叫它CSS变量，然而它实际上却不叫做CSS变量，而是叫做CSS自定义属性，即CSS Custom Property，以下分别摘自w3.org和MDN： This module introduces cascading variables as a new primitive value type that is accepted by all CSS properties, and custom properties for defining them. —— w3.org The var() CSS function can be used to insert the value of a custom property (sometimes called a “CSS variable”) instead of any part of a value of another property. —— MDN 虽然在MDN中有提及sometimes called a &quot;CSS variable&quot;，但是它应该叫做CSS自定义属性而不是CSS变量。 如何声明一个CSS自定义属性？在声明的时候我们需要在自定义属性名前添加两条横线-- 1234:root &#123; --border-color: #ff0000; --text-color: #ff0000;&#125; 上面的代码的意思是：我们在:root作用域中声明了两个自定义属性，分别是--border-color和--text-color。 为什么在CSS的自定义属性中，使用的是两条横向--而不是其他的如$或者@，是因为这几个前缀被Sass和Less使用了，官方为了避免引起冲突和误解，使用了--。 需要注意的是，css的自定义属性名对大小写敏感，也就是说--color和--Color是两个自定义属性。 在CSS自定义属性中我们可以存入哪些值？在CSS中的各种值都可以放入CSS自定义属性中，如： 1234567891011:root &#123; --color: #ff0000; --rgba-color: rgba(255, 0, 0); --px: 1px; --border: 1px solid red; --padding: 10px 10px; --line-height: 1.5; --durations: .5s; --text: "text"; --calc-top: calc(100vh - 44px);&#125; var()函数通过var()函数读取一个CSS自定义属性，然后代替元素中的任何属性中的值的任何部分，但是var()函数不能作为一个属性名、选择器或者其他除了属性值之外的值，例子： 1234567891011121314151617181920body &#123; --hello-world: "margin-top"; var(--hello-world): 1px solid red;/*错误，不能用做属性名*/ --margin-top: 20; margin-top: var(--margin-top)px;/*错误，如何自定义属性值是数值，不能与数值单位直接连用*/ margin-top: calc(var(--margin-top) * 1px);/*正确，若为数值，需要通过calc()函数连接使用*/ --padding-top: "20px"; padding-top: var(--padding-top);/*错误，若带有单位，则不能写为字符串*/ --padding-bottom: 20px; padding-bottom: var(--padding-bottom);/*正确*/ --border-color: #ff0000; border: 1px solid var(--border-color);/*正确，替换属性值的部分的值的时候中间不能加入其他符号，需要用空格进行分隔*/&#125;var(--hello-world) &#123; /*错误，不能用做选择器*/&#125; var()函数有一个方法： 1var( &lt;custom-property-name&gt; , &lt;declaration-value&gt;? ) 第一个参数为自定义属性的名称，第二个参数为回退值，即当第一个参数引用的自定义属性无效（未声明、声明的值错误）情况下，则使用第二个参数的值。 123456789101112&lt;style&gt; span &#123; --color: red; &#125; div &#123; color: var(--color, blue); &#125;&lt;/style&gt;&lt;body&gt; div标签：&lt;div&gt;蓝色&lt;/div&gt;&lt;/body&gt; 在上面的例子中，我们在span作用域中声明了一个--color: red自定义属性，值为red，当我们在div选择器中使用时无法获取到span作用域的自定义属性，所以被判定为无效的，然后就会使用回退值，所以div标签的color属性的值为blue，作用域我们将在下面的内容中讲解。 css自定义属性的作用域同一个CSS自定义属性名可以在多个选择器内声明及赋值，当元素在读取CSS自定义属性的时候会根据优先级最高声明，类似于CSS层叠(CSS Cascade)的规则。 12345678910111213141516171819202122&lt;style&gt; :root &#123; --color: red; &#125; div &#123; --color: green; &#125; #blue &#123; --color: blue; &#125; * &#123; color: var(--color); &#125;&lt;/style&gt;&lt;body&gt; p标签：&lt;p&gt;红色&lt;/p&gt; div标签：&lt;div&gt;绿色&lt;/div&gt; id为blue的div标签：&lt;div id="blue"&gt;蓝色&lt;/div&gt;&lt;/body&gt; 我们可以看到，在上面的代码中的:root、div、id三个选择器的作用域中都声明了--color自定义属性，但是当不同的元素在获取自定义属性的时候，都会采用优先级最高的那个，所以这三个标签中的文字的color都是不同的。其中:root是根作用域，通常将全局自定义属性在该作用域中声明，以确保所有选择器都可以读取。 同时，我们也可以知道了，CSS自定义属性只在他的作用域内生效： 12345678910111213141516171819202122232425262728&lt;style&gt; * &#123; color: blue; &#125; body &#123; --body-color: green; &#125; div &#123; --div-color: green; color: var(--span-color); &#125; span &#123; --span-color: red; color: var(--span-color); &#125; p &#123; color: var(--body-color); &#125;&lt;/style&gt;&lt;body&gt; div标签：&lt;div&gt;蓝色&lt;/div&gt; p标签：&lt;p&gt;绿色&lt;/p&gt; span标签：&lt;span&gt;红色&lt;/span&gt;&lt;/body&gt; 从上面的例子中，我们可以发现： 子元素可以使用父元素作用域中的自定义属性值，即body作用域中定义了一个--body-color: green的自定义属性，在p元素中使用这个自定义属性值的时候是可以获取的。 兄弟元素无法获取对方作用域中的自定义属性的值，div元素使用span元素作用域中声明的自定义属性时，会因为作用域不同的原因，只能使用在*选择器中的color属性的值。 通过JavaScript操作CSS自定义属性我们可以通过JavaScript的CSS.supports属性检测当前浏览器是否支持CSS自定义属性： 12345678910const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports('--a', 0);if (isSupported) &#123; /* supported */&#125; else &#123; /* not supported */&#125; JavaScript中操作CSS自定义属性的方法： 123456789// 设置变量document.body.style.setProperty('--color', '#ff0000');// 读取变量document.body.style.getPropertyValue('--color').trim();// '#ff0000'// 删除变量document.body.style.removeProperty('--color'); 上面的代码的意思是给body元素的作用域中设置一个--color: #ff0000的CSS自定义属性，然后并读取、删除它。 这就使得我们可以向CSS自定义属性中添加任何值： 1document.body.style.setProperty('--color', 'hello world'); 上面的代码在CSS中是无效的值，但是我们可以通过JavaScript进行读写操作，也就是说CSS自定义属性能够实现JavaScript和CSS之间的通信。 var()函数以及CSS自定义属性在实际使用中的作用通过var()函数和CSS自定义属性，我们可以实现在不使用Less、Sass或Stylus的情况下，修改项目的主题等操作。 通过JavaScript修改右侧.ui-dialogbox选择器的border颜色达到切换主题的效果。 在Vue工程中使用CSS自定义属性和var()函数的坑通过上文我们可以知道:root作用域中声明的CSS自定义属性可以在任何选择器中使用，但是在Vue的单页应用中我们得到的效果却跟你所期望的不一样，甚至是无效的。 这是因为如果你在Vue的单文件中，即后缀为.vue的文件的style标签中使用了scoped，那么Vue会对在该style标签中的所有选择器添加一个前缀，大概如下： 123[data-v-1374924e]:root &#123; --color: red;&#125; 这个时候，:root作用域就不是根作用域，所以你在该组件中看到的CSS自定义属性的值是无效的或者是错误的。 那么我们该如何解决呢，有三种方法： 在Vue的index.html文件中添加style标签，在该标签内的:root作用域中声明全局CSS自定义属性。 编写一个外部CSS文件，在该文件中的:root作用域中声明全局CSS自定义属性。 在该组件的最外层元素的作用域即选择器中声明CSS自定义属性，这样该组件的所有子元素都可以使用。]]></content>
      <categories>
        <category>CSS学习</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用hexo命令行写一篇文章]]></title>
    <url>%2F2019%2F05%2F16%2Fblog%2Fwrite-blog%2F</url>
    <content type="text"><![CDATA[常用的Hexo指令Hexo的常用指令均可在官网中查看 初始化 1hexo init [folder] 用于初始化、新建一个网站，如果不写folder，则在当前目录下初始化。 新建一篇文章 1hexo new [layout] &lt;title&gt; 如果未设置layout，则使用_config.yml中的default_layout参数设置，如果新建的标题中带有空格，需使用&quot;&quot;将标题括起。该指令有简写： 1hexo n &lt;title&gt; 生成静态文件，即我们常说的打包 1hexo generate 键入命令并执行之后会在你的网站目录下生成一个public目录，即打包出来的静态资源文件均存储于此，该指令可以简写： 1hexo g 其中可以在后方加入一些选项： | 选项 | 选项 || —————- | ——————————– || -d，--deploy | 静态资源文件生成之后立即部署网站 || -w，--watch | 监视文件变动 | 启动网站的本地服务器，一般用于预览网站内容，默认情况下访问网址为：http://localhost:4000 1hexo server 可以在启动服务器的时候添加参数 选项 描述 -p，--port 设置端口号 -s，--static 仅使用静态文件 -l，--log 记录日志，同时覆盖旧日志 该命令可以简写为： 1hexo s 部署网站 1hexo deploy | 选项 | 描述 || —————— | —————————— || -g，--generate | 部署网站内容之前先生成静态资源 | 该命令可以简写为： 1hexo d 通过hexo n生成的md文件如何设置标签、分类、简介一般通过hexo n命令生成的md文件中，在文件的最顶部会有三个属性title、date、tags，这三个分别对应文章标题，文章创建日期，文章标签。如果你在之前的Hexo设置中开启了分类即categories，则可以在虚线之上新起一行，添加一个属性categories，这个时候你的这篇文章就有了分类。如果添加description则可以为文章添加简介，如果没有简介则在Hexo主页中会显示文章的全文，添加简介后只显示简介。其中，仅有tags和categories属性可以使用[]方括号，其他属性均不允许使用，否则会在部署的时候报错。 tags和categories的用法一致，需要使用[]将标签名、分类名包裹起来，其中通过,（英文的逗号）隔开。 其他属性直接输入字符串就好了。 然后在本文的最后，推荐一款markdown编辑器Typora。官网and下载地址]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter学习日志03]]></title>
    <url>%2F2019%2F05%2F13%2FFlutterStudy%2Fflutter03%2F</url>
    <content type="text"><![CDATA[Flutter的布局方式在Flutter中，所有布局都是基于Widdget进行的，因为对于Flutter而言，任何东西都是一个Widdget，不论是布局模型、图像、文本等等，还是我们看不到的东西比如行row、列column等等都是一个Widdget。 如果我们想构建一个复杂的Widdget，可以通过多个不同的简单Widdget组合而成，]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter学习日志02]]></title>
    <url>%2F2019%2F05%2F06%2FFlutterStudy%2Fflutter02%2F</url>
    <content type="text"><![CDATA[在本文中我仅介绍Android Studio创建一个Flutter应用，不考虑其他IDE Flutter应用初体验 创建应用 点击File -&gt; New -&gt; New Flutter Project新建一个flutter应用 选择Flutter Application创建一个Flutter应用程序 修改Project name来设置你自己的工程的名称、SDK路径、工程路径以及简介 修改Company domain的名称 点击Finish完成创建 运行Flutter程序 添加并启动一个AVD虚拟机 点击右上角小手机按钮打开虚拟机管理界面，或者点击菜单栏中的Tools -&gt; AVD Manager打开虚拟机管理界面 在虚拟机管理界面中点击Create Virtual Device...按钮添加一个虚拟机 选择并创建一台设备，点击Next进入下一步 选择一个系统镜像，我这里是因为之前提前下载好了Android 9.+的系统镜像，如果要选择其他的镜像请根据个人需求选择下载，点击Next进入下一步 在虚拟机配置中开启硬件加速Hardware-GLES 2.0，点击Show Advanced Settings显示高级设置，在Emulated Performance中的Graphics选项中选择Hardware-GLES 2.0，点击Finish完成虚拟机的创建 在虚拟机列表中点击Actions标签下的三角形图标启动虚拟机，到此虚拟机创建以及启动的教程结束。 启动Flutter应用 在AVD虚拟机已经启动的情况下，点击Android Studio右上角的绿色三角形运行Flutter程序，或者点击菜单栏中的Run -&gt; Run &#39;main.dart&#39;运行Flutter程序 当AVD虚拟机中出现上图所示程序界面的时候，说明我们的Flutter程序能够正常运行 编写我们的Hello World!程序 在第二步中我们创建的Flutter程序中不难看出，flutter_app/lib/main.dart是Flutter程序的主文件即入口文件，我们替换该文件中的所有代码，替换成以下代码（我们先不讲Dart语法以及Flutter API）： 1234567891011121314151617181920212223242526import &apos;package:flutter/material.dart&apos;;//主函数（入口函数），下面我会简单说说Dart的函数void main() =&gt; runApp(MyApp());// 声明MyApp类class MyApp extends StatelessWidget &#123; //重写build方法 @override Widget build(BuildContext context) &#123; //返回一个Material风格的组件 return MaterialApp( title: &apos;Welcome to Flutteraa&apos;, home: Scaffold( //创建一个Bar，并添加文本 appBar: AppBar( title: Text(&apos;Welcome to Flutter&apos;), ), //在主体的中间区域，添加一个hello world 的文本 body: Center( child: Text(&apos;Hello World&apos;), ), ), ); &#125;&#125; 当我们保存修改的时候，模拟器中的程序界面应该已经变成了Hello World，如下图：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter学习日志01]]></title>
    <url>%2F2019%2F05%2F05%2FFlutterStudy%2Fflutter01%2F</url>
    <content type="text"><![CDATA[前言在掘金看大神的文章时突然看到关于Flutter的介绍，一瞬间觉得这个比weex要强大太多了，然后就开始了Flutter的学习之旅，本文是我在观看@技术胖前辈的教学视频以及学习了教程之后的学习记录，这是该系列的第一篇，该系列我会保持一天一更，记录我每天的学习进度。 什么是Flutter在Flutter中文网中是这样介绍Flutter的： Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 通过官网介绍，我们可以简单的了解到Flutter是一个开源的、跨平台(iOS和Android)的、移动UI框架，官方对其的特点归纳为以下几个： 快速开发： 毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 富有表现力和灵活的UI 快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 原生性能 Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。 windows下配置Flutter环境因为我只有windows环境，所以mac以及linux环境暂不讨论；其中编辑器仅讨论Android Studio，其他如VSCode等IDE暂不讨论。 在配置之前我们需要提前准备好以下： Git命令行工具 Flutter SDK Java jdk Android Studio 1. 安装Git for Windows因为Flutter依赖Git命令行工具即Git for Windows，所以需要提前安装好Git for Windows，并且确保能够在CMD和PowerShell中能运行Git命令，否则在之后的步骤中运行flutter doctor时将会出现Unable to find git in your PATH的错误。 2. 配置Flutter SDK 下载最新的安装包 最新的安装包请从Flutter官网中自行下载，天朝的各位可能需要科学上网打开这个可能不存在的网站，也可以在Flutter的GitHub项目中获取最新的安装包 将安装包zip文件解压到对应的路径，如C:\src\flutter，注意，不要将Flutter安装到需要一些高权限的目录中，如C:\Program Files\ 在Flutter的解压根目录下双击运行flutter_console.bat脚本文件，就可以在打开的命令行窗口中运行Flutter命令了 因为在Flutter中有部分命令需要联网获取数据，大家都知道连接的是不存在的网站，所以我们需要提前配置好用户环境变量，在控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 用户变量中新建两个变量PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL。对大陆的用户来说，这步非常重要，如果未配置则会影响之后的开发 PUB_HOSTED_URL = https://pub.flutter-io.cn FLUTTER_STORAGE_BASE_URL = https://storage.flutter-io.cn 如果需要在CMD或者PowerShell中运行flutter命令，则需要在用户环境变量中添加相关变量 在“用户变量”下检查是否有名为Path的条目： 如果该条目存在, 追加%FLUTTER_HOME%\bin的全路径，使用;作为分隔符 如果条目不存在, 创建一个新用户变量Path，然后将%FLUTTER_HOME%\bin的全路径作为它的值 最后重启Windows让该环境变量生效 3. 运行flutter doctor打开一个新的CMD或者PowerShell命令行窗口并输入以下命令是否完成flutter的安装 如果没有红色的x到此就完成Flutter的安装了 今天的内容暂时到此为止，明天将更新解决flutter doctor的部分错误以及安装的坑 2019年5月6日补充的内容响了一下，大家可能最常见的也是碰到最多的问题应该是在第一次运行Flutter的时候卡在Resovle...阶段，然后等了很长一段时间之后控制台报错，其中在日志中有一句信息： 1ProcessException: Process "你的flutter工程路径\flutter_app\android\gradlew.bat" exited abnormally: 这个报错的原因是因为天朝的墙太厚了，看不到拿不到墙外面的东西，解决这个问题请参考本文中配置Flutter SDK下的第3点中的配置信息，即在环境变量中新建两个变量PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL，对大陆的用户来说，这步非常重要，如果未配置则会影响之后的开发 PUB_HOSTED_URL = https://pub.flutter-io.cn FLUTTER_STORAGE_BASE_URL = https://storage.flutter-io.cn]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas实现渐变色环形进度条]]></title>
    <url>%2F2019%2F04%2F09%2Fcomponents%2FProgressBarComponent%2FProgreeBar%2F</url>
    <content type="text"><![CDATA[最近的项目用到一个渐变色的环形进度条，原本说要百度一个（我承认我懒），然后发现，都不是自己需要的_(:зゝ∠)_，没办法，撸起袖子整一个出来吧。 先上一个图！ 核心实现首先我们需要在html页面中添加一个canvas标签 1&lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas&gt; 接下来我们实现canvas的绘制过程。 其实这个圆环就是绘制两个圆然后叠加在一起，灰色的放在底下，带颜色的放在上边 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取canvas元素let canvas = document.getElementById('canvas');let ctx = canvas.getContext("2d");let width = canvas.width;let height = canvas.height;let circleObj = &#123; ctx: ctx, /*圆心*/ x: width / 2, y: width / 2, /*半径*/ radius: width / 2 - 10,//半径比canvas宽的一半要小 /*环的宽度*/ lineWidth: 10&#125;;/*灰色的圆环*/circleObj.startAngle = Math.PI * 2;circleObj.endAngle = Math.PI * 2 / 4; // 对应 360° 的 1/4 即 90°circleObj.color = '#e9e9e9';drawCircle(circleObj);/*有色的圆环*//*开始的度数-从上一个结束的位置开始*/circleObj.startAngle = circleObj.endAngle;/*结束的度数 Math.PI * 2 */circleObj.endAngle = Math.PI * 2;circleObj.color = "#dd6200";drawCircle(circleObj);/*画曲线*/function drawCircle(circleObj) &#123; let ctx = circleObj.ctx; ctx.beginPath(); ctx.arc(circleObj.x, circleObj.y, circleObj.radius, circleObj.startAngle, circleObj.endAngle, false); //设定曲线粗细度 ctx.lineWidth = circleObj.lineWidth; //给曲线着色 ctx.strokeStyle = circleObj.color; //连接处样式 ctx.lineCap = 'round'; //给环着色 ctx.stroke(); ctx.closePath();&#125; 这个时候我们可以到页面上看一下效果 为什么跟我们最终的效果差距那么大？渐变色呢？而且进度条的起点位置也不对啊？这些问题让我们一个个解决。 调整起始点位置 因为在canvas中绘制一个圆形，起点并不在圆形的顶部，而是在时钟3点方向，然后顺时针绘制，在w3c中解释如下： 所以我们需要对这个圆进行选装，逆时针旋转90°，但是又因为在canvas中要进行旋转只能对画布进行旋转，所以我们需要修改圆的圆心以及画布旋转的中心点： 12345678910111213141516.../*开始圆环*/let circleObj = &#123; ctx: ctx, /*圆心*/ x: 0, y: 0, /*半径*/ radius: width / 2 - 10, //半径比canvas宽的一半要小 /*环的宽度*/ lineWidth: 10&#125;;ctx.translate(width / 2, height / 2); // 将画布原点移动到中心位置ctx.rotate(-Math.PI / 2); // 旋转-90°... 到此页面显示的如下： 这个时候起点的位置的确已经移动到圆的顶部了，可是进度条的绘制方向不对啊，怎么逆时针画了，其实这是因为我们先画了灰色的圆再花有色的圆，然后通过改变灰色的圆的终点改变有色的圆的绘制起点，所以看起来就像是反着绘制圆了，解决这个的方法很简单，我们把圆在Y轴上翻转180°就好了： 1234567891011121314151617.../*开始圆环*/let circleObj = &#123; ctx: ctx, /*圆心*/ x: 0, y: 0, /*半径*/ radius: width / 2 - 10, //半径比canvas宽的一半要小 /*环的宽度*/ lineWidth: 10&#125;;ctx.translate(width / 2, height / 2); // 将画布原点移动到中心位置ctx.scale(-1, 1); // 翻转180°ctx.rotate(-Math.PI / 2); // 旋转-90°... 这个时候再看一下页面就跟我们想要的一致了： 记得在调整画布中心点之后，圆的圆心应该为(0, 0) 设置渐变色 在canvas中设置渐变色需要使用createLinearGradient这个API，并添加起止位置的颜色，我们在有色圆环绘制的代码块下添加： 1234567891011121314.../*有色的圆环*//*开始的度数-从上一个结束的位置开始*/circleObj.startAngle = circleObj.endAngle;/*结束的度数 Math.PI * 2 */circleObj.endAngle = Math.PI * 2;let grd = ctx.createLinearGradient(width / 2, 0, 0, height);grd.addColorStop(0, _this.startColor);grd.addColorStop(1, _this.endColor);circleObj.color = grd;drawCircle(circleObj);... 这个时候进度条的颜色应该变成渐变的黄色 到了这里，基本这个渐变的环形进度条就已经完成了，接下来，我们要让这个进度条动起来。 进度条动画的实现为了实现进度条的动画，我们要先明白增长的是哪个圆？之前我们是先通过缩短灰色的圆实现有色的圆的增长，那么灰色的圆最开始应该是360°，这样相对的有色的圆就是0°，由此，我们可以通过减少灰色的圆的度数实现有色的圆的度数的增长，即进度条长度的增加。 通过window.requestAnimationFrameAPI可以快速的实现一个逐帧动画。 以下就是加上逐帧动画之后的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980let canvas = document.getElementById('canvas');let ctx = canvas.getContext("2d");let width = canvas.width;let height = canvas.height;ctx.translate(width / 2, height / 2); // 将画布原点移动到中心位置ctx.scale(-1, 1); // 翻转180°ctx.rotate(-Math.PI / 2); // 旋转-90°// 设置最开始灰色的圆为360°即 Math.PI * 2let defaultAngle = Math.PI * 2;animate();function animate() &#123; // 逐帧动画 defaultAngle -= 0.15; // 这个值可以根据个人需要修改 // 因为我们设置的是灰色的圆的角度，对应的就是有色的圆的度数，即假设灰色的圆90°(1/4)的时候，有色的圆占比就为3/4 draw(); if (defaultAngle &lt;= Math.PI * 2 * (1 - 3 / 4)) &#123; draw(); // 当动画结束的时候再绘制一次 return &#125; window.requestAnimationFrame(animate);&#125;function draw() &#123; // 为了避免每次绘制的时候出现一些奇奇怪怪的问题，比如拖影之类的，每次绘制之前清空一次绘布 ctx.clearRect(0, 0, width, height); let circleObj = &#123; ctx: ctx, /*圆心*/ x: 0, y: 0, /*半径*/ radius: width / 2 - 10,//半径比canvas宽的一半要小 /*环的宽度*/ lineWidth: 10 &#125;; /*灰色的圆环*/ circleObj.startAngle = Math.PI * 2; circleObj.endAngle = defaultAngle; // 对应 360° 的 1/4 即 90° circleObj.color = '#e9e9e9'; drawCircle(circleObj); /*有色的圆环*/ /*开始的度数-从上一个结束的位置开始*/ circleObj.startAngle = circleObj.endAngle; /*结束的度数 Math.PI * 2 */ circleObj.endAngle = Math.PI * 2; let grd = ctx.createLinearGradient(width / 2, 0, 0, height); grd.addColorStop(0, "#fff400"); grd.addColorStop(1, "#dd6200"); circleObj.color = grd; drawCircle(circleObj);&#125;/*画曲线*/function drawCircle(circleObj) &#123; let ctx = circleObj.ctx; ctx.beginPath(); ctx.arc(circleObj.x, circleObj.y, circleObj.radius, circleObj.startAngle, circleObj.endAngle, false); //设定曲线粗细度 ctx.lineWidth = circleObj.lineWidth; //给曲线着色 ctx.strokeStyle = circleObj.color; //连接处样式 ctx.lineCap = 'round'; //给环着色 ctx.stroke(); ctx.closePath();&#125; 最终效果]]></content>
      <categories>
        <category>vue组件</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>component</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中如何实现一个发送请求的遮罩]]></title>
    <url>%2F2019%2F04%2F09%2Fcomponents%2FIndicatorComponent%2Findicator%2F</url>
    <content type="text"><![CDATA[最近的项目需要自定义一个能在axios发送请求的时候显示的遮罩，然后顺手写了一个简单的组件出来，在任何地方都可以使用；通过Vue.extend()实现。 Vue.extend()是什么？Vue.extend是一个扩展实例构造器，也就是说这是一个可以预设部分属性的Vue实例构造器，主要作用是用来生成组件。 如何创建一个Vue.extend()创建一个Vue.extend我们需要传入一个参数options，这个参数是一个包含创建component组件选项的对象，在Vue.extend中data必须是函数。 1&lt;div id="mount-point"&gt;&lt;/div&gt; 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') 页面显示结果如下： 1&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; 实现一个Indicator通过上文我们可以实现一个简单的Vue.extend实例，但是在axios中实现需要进行一些改动。 在axios配置中我们需要只能通过调用方法的方式显示遮罩所以我们需要在一个js文件中编写显示遮罩和隐藏遮罩的函数。 目录结构： 1234indicator |---- index.js # 入口文件 |---- indicator.vue # vue组件 |---- loading.gif # 用到的gif图 首先我们在indicator.vue文件中实现一个全屏遮罩以及我们的loading图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;transition name="fade"&gt; &lt;div class="ui-loading" v-if="visible"&gt; &lt;div class="ui-loading-back"&gt; &lt;img src="./loading.gif"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "ui-loading", props: &#123; visible: &#123; //控制loading显隐 type: Boolean, default: false &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .ui-loading &#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, .7); display: flex; justify-content: center; align-items: center; z-index: 9999; &#125; .ui-loading-back &#123; width: 150px; height: 150px; display: flex; justify-content: center; align-items: center; &#125; .ui-loading-back &gt; img &#123; width: 150px; height: 150px; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .5s; &#125; .fade-enter, .fade-leave-to &#123; height: 0; &#125;&lt;/style&gt; 这个组件其实很简单，就做了一个背景透明度为0.7的页面，并在页面水平垂直居中了一个gif图。 然后我们开始编写最重要的入口文件index.js: 123456789101112131415161718192021222324252627import Vue from 'vue' // 引入Vueimport Loading from './loading.vue' // 引入要动态创建的vue模板const Indicator = Vue.extend(Loading); // 创建一个Vue的“子类”let instance;export default &#123; open() &#123; if (!instance) &#123; instance = new Indicator(&#123; el: document.createElement('div') &#125;); &#125; if (instance.visible) return; document.body.appendChild(instance.$el); Vue.nextTick(() =&gt; &#123; instance.visible = true; &#125;); &#125;, close() &#123; if (instance) &#123; instance.visible = false; &#125; &#125;&#125; 接下来我们就可以通过模块引入的方式使用了 12345678910111213141516171819202122// 在axios拦截配置文件中添加import Indicator from "@/component/indicator"... // request 拦截 instance.interceptors.request.use( res =&gt; &#123; // 显示遮罩 Indicator.open(); return res &#125;, err =&gt; &#123; return Promise.reject(err) &#125; ) ... // response 拦截器 instance.interceptors.response.use( response =&gt; &#123; // 隐藏遮罩 Indicator.close(); ... 如果需要在vue页面中使用，方式跟上面的相似。 效果图]]></content>
      <categories>
        <category>vue组件</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mini版网易云音乐for electron-vue开发日志1]]></title>
    <url>%2F2019%2F03%2F25%2FNeteseCloudMusic%2FMiniApp%2Fday1%2F</url>
    <content type="text"><![CDATA[跨域问题依旧是这个问题，太头疼了的一个问题，因为API服务器是用的@Binaryify的GitHub项目，我放到我的阿里云服务器上直接用pm2启动后就不管了，然后尝试了在google和baidu中搜到的方案(也许真正的方案我没搜到)，发现都没办法，然后干脆给axios设置的一个baseURL（不是因为我懒），毕竟我的所有请求都发向我的服务器地址，所以也算是一个解决方案吧 12axios.defaults.baseURL = "服务器地址";Vue.http = Vue.prototype.$http = axios 解决本地测试的界面比build之后的界面较小最开始一直在本地开发以及测试，然后发现我build然后运行后，整个界面，包括字体、宽高等等的样式全部变大了，尝试在src/main/index.js中修改视窗比例后发现无效，在某不存在的网站google上搜到了一个解决方案，这个方案来自这是地址 123456let devInnerHeight = 1080.0 // 开发时的InnerHeightlet devDevicePixelRatio = 1.0// 开发时的devicepixelratiolet devScaleFactor = 1 // 开发时的ScaleFactorlet scaleFactor = require('electron').screen.getPrimaryDisplay().scaleFactorlet zoomFactor = (window.innerHeight / devInnerHeight) * (window.devicePixelRatio / devDevicePixelRatio) * (devScaleFactor / scaleFactor)require('electron').webFrame.setZoomFactor(zoomFactor) 这里修改需要在src/renderer/main.js内添加]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>网易云音乐</tag>
        <tag>electron-vue</tag>
        <tag>vue</tag>
        <tag>个人项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue刮刮乐组件]]></title>
    <url>%2F2019%2F03%2F06%2Fcomponents%2FScratchComponent%2FScratch%2F</url>
    <content type="text"><![CDATA[因为之前的项目中有用到h5小游戏，其中有一个就是刮刮乐，正好canvas最近用的次数很多，想了想，就用canvas写一个吧。 一、演示图先上一个演示，就不把演示放到文末了。 二、实现思路其实刮刮乐算是canvas中入门的一种使用了，简单地说实现的过程，用canvas绘制一个灰色的涂层，然后监听mousedown、mousemove和mouseup事件，在移动端中则是监听touchstart、touchmove和touchend事件，这个过程就是我们“刮开”刮刮乐的过程了。那么这么设计的页面中，实际有两层，第一层当然是我们的灰色的涂层啦，第二层就是我们的中奖文字或者中奖图片。 三、开始 首先我们需要在页面上先绘制一个canvas“涂层” 123456&lt;!-- 这是一个canvas --&gt;&lt;canvas id="canvas" width="300" height="185"&gt; 很遗憾你的浏览器不支持canvas&lt;/canvas&gt; 接着，咱们给这个涂层上个色 12345678910//获取我们canvas元素let canvas = document.getElementById("canvas"); //设置一个上下文为"2d"的画布let ctx = canvas.getContext("2d");//开始绘制一个涂满灰色的矩形，其中宽高为canvas的宽高ctx.save();ctx.fillStyle = "#666";ctx.fillRect(0, 0, canvas.width, canvas.height);ctx.restore(); 这个时候你应该能在你的页面上看到一个灰色的涂层了 接下来，我们开始实现“刮开”这一个过程了，这个过程思路很简单，我在这里以移动端做举例： 手指按下按在屏幕上，这个时候监听到touchstart事件 在touchstart事件里再监听touchmove事件用以判断手指头是否在屏幕上滑动 根据我们手指的路径去“清除”canvas中画好的灰色图层 最后在手指离开屏幕触发touchend事件的时候判断我们清除了多少的像素，达到一定比例直接隐藏涂层 思路理清了，咱们开始吧！ 因为要考虑同时兼容pc端和移动端，所以我们需要考虑设备信息是哪种设备 1234let device = /android|iphone|ipad|ipod|webos|iemobile|opear mini|linux/i.test(navigator.userAgent.toLowerCase()); //判断是否是移动设备let startEvtName = device ? "touchstart" : "mousedown";let moveEvtName = device ? "touchmove" : "mousemove";let endEvtName = device ? "touchend" : "mouseup"; 接下来我们编写清楚涂层的方法 12345678910111213141516171819function clear(event) &#123; if (flag) &#123; //获取鼠标或者手指距离屏幕的x坐标 let x = device ? event.targetTouches[0].clientX : event.clientX; //获取鼠标或者手指距离屏幕的y坐标 let y = device ? event.targetTouches[0].clientY : event.clientY; //获取canvas元素相对于视窗的位置 let bbox = canvas.getBoundingClientRect(); //开始绘制涂抹动作的canvas ctx.beginPath(); //canvas的globalCompositeOperation属性指的是canvas中的合成操作 //将该属性设置为"destination-out"会将在与canvas源不重叠的区域上保留目标，其他部分都变成透明 ctx.globalCompositeOperation = "destination-out"; //因为要模拟手机涂抹过程，所以涂抹的图形选择圆形，在这里绘制一个原型，半径为20px ctx.arc(x - bbox.left, y - bbox.top, 20, 0, Math.PI * 2, false); ctx.fill(); ctx.closePath(); &#125;&#125; 最后我们开始监听鼠标或者手指触发的事件 1234567//监听开始即鼠标按下或者手指触摸时的事件canvas.addEventListener(startEvtName, (e) =&gt; &#123; //用于判断鼠标/手指是否触摸涂层 flag = true; //监听鼠标移动或者手指移动的事件，同时调用clear函数清楚图层 canvas.addEventListener(moveEvtName, clear, false);&#125;, false); 这里设置好之后我们就可以开始实现刮开的动作了 但是在刮开涂层的过程中我们会发现，假如页面有滚动条，我们会拖着页面一起滚动，那我们来解决这个问题吧！ 1234567canvas.addEventListener(startEvtName, (e) =&gt; &#123; //禁止会引起屏幕滚动的事件 e.preventDefault(); //用于判断鼠标/手指是否触摸涂层 flag = true; canvas.addEventListener(moveEvtName, clear, false);&#125;, false); 我们通过e.preventDefault()来禁用屏幕滚动，这下我们再刮开涂层试试，是不是就不会滚动了？ 接下来，我们来实现当刮开一定面积的涂层的时候涂层自动消失 1234567891011121314151617181920212223//监听鼠标弹起或者手指离开屏幕的事件canvas.addEventListener(endEvtName, () =&gt; &#123; //用于判断鼠标/手指是否触摸涂层 flag = false; //获取canvas全部的像素点，这里需要用到getImageData方法 //getImageData(int x,int y,int width,int height)：该方法获取canvas上从(x,y)点开始，宽为width、高为height的图片区域的数据，该方法返回的是一个CanvasPixelArray对象，该对象具有width、height、data等属性。data属性为一个数组，该数组每4个元素对应一个像素点。 let imageDate = ctx.getImageData(0, 0, canvas.width, canvas.height); //记录整个canvas所有像素点 let allPX = imageDate.width * imageDate.height; //记录刮开的像素点个数 let iNum = 0; //通过for循环判断刮开了多少个像素点 for (let i = 0; i &lt; allPX; i++) &#123; if (imageDate.data[i * 4 + 3] == 0) &#123; iNum++; &#125; &#125; //当刮开的像素点数量大于等于总像素点数量的40%时隐藏canvas if (iNum &gt;= allPX / 2.5) &#123; canvas.style.display = "none"; &#125;&#125;, false); 四、结语具体怎么移植到vue里我就不做介绍啦~感谢大家看到这里，有什么我讲不清楚的麻烦在评论区给我留个言！！！ 最后再次感谢大家！]]></content>
      <categories>
        <category>vue组件</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>component</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueStudy]]></title>
    <url>%2F2019%2F03%2F04%2FJavaScript%2FVUE%2FVueStudy%2F</url>
    <content type="text"><![CDATA[一、name值没写对引起的死循环在实战中不小心将页面的name值写成了页面中调用的一个组件的name值，然后在进入页面之后报错，百度之后是因为发生了死循环： 找了半天注释掉了各种for循环或者forEach超级循环等代码之后还是报这个错误。挠头想了一想，突然瞥到页面的name值和组件的name值写的一样了，然后修改了页面的name值之后一切正常。 二、在vue中格式化input框中v-model的内容当我们需要格式化一个内容的时候可以直接使用filters，例如 1&lt;span&gt;&#123;&#123;inputDate | date&#125;&#125;&lt;/span&gt; 但是当我们需要格式化的对象是input标签的v-model的时候发现filters并不起作用。 这是因为input标签的特性决定的：所见即所得。即value属性的值就是显示的值。 在vue中，其实v-model是封装了v-bind和v-on的一个语法糖，如果我们需要格式化input输入框中的内容的时候，我们需要通过v-on去调用一个方法去格式化v-bind绑定的值。 三、在vue组件中，:root定义的全局变量无效如果在组件或者单页中使用了scoped，那么在声明:root作用域设置css变量，你会发现:root中的变量并未生效。 原因是因为vue的scoped特性，会在该单页或者组件中在:root之前添加上标识如[data-v-xxx]:root，然后css变量在寻找:root作用域的时候其实是寻找了index.html或者父页面、父组件的:root，所以该变量值会为空。 解决方案： 在index.html中设置:root作用域 在该单页或者组件的最外层父元素中添加变量 通过引入公共css样式并在该样式文件中添加:root作用域]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Study]]></title>
    <url>%2F2019%2F03%2F01%2FJavaScript%2FStudy%2FStudy%2F</url>
    <content type="text"><![CDATA[一、复制变量在JavaScript中复制变量时，从一个变量向另一个变量复制基本类型值和引用类型值时会存在不同的结果。 例子： 12345678910111213141516// 当被复制的变量是一个基本类型值时var num1 = 1;var num2 = num1;console.log("num1:", num1); // 输出 num1: 1console.log("num2:", num2); // 输出 num2: 1num1 = 3;console.log("num1:", num1); // 输出 num1: 3console.log("num2:", num2); // 输出 num2: 1num2 = 4;console.log("num1:", num1); // 输出 num1: 3console.log("num2:", num2); // 输出 num2: 4 123456789101112131415161718// 当被复制的变量是一个引用类型值时var obj1 = &#123; name: "obj1"&#125;;var obj2 = obj1;console.log("obj1", obj1); // 输出 obj1 &#123;name: "obj1"&#125;console.log("obj2", obj2); // 输出 obj2 &#123;name: "obj1"&#125;obj1.name = "hahaha";console.log("obj1", obj1); // 输出 obj1 &#123;name: "hahaha"&#125;console.log("obj2", obj2); // 输出 obj2 &#123;name: "hahaha"&#125;obj2.name = "abcd";console.log("obj1", obj1); // 输出 obj1 &#123;name: "abcd"&#125;console.log("obj2", obj2); // 输出 obj2 &#123;name: "abcd"&#125; 在例子中我们会发现，当我们复制一个基本类型值的时候，我们改变num1的值时，num2的值还是之前的值不变；但是当我们复制一个引用类型的时候，我们改变obj1中的name属性值之后，obj2中的name属性值也发生了改变。 如果从一个变量向另一个变量复制基本类型的值，会在内存栈中新建一个对象，然后将复制的这个变量复制到这个新的对象中，这个时候内存中就存在两个不同的对象，所以当我们在改变其中一个的值的时候另一个的值不受影响。 如果从一个变量向另一个变量复制引用类型的值时，同样也会在内存栈中新建一个对象，然后将这个值复制到新建的对象中，但是不同的是，这个时候在内存中储存的不是一个实际的值，而是指向内存堆中一个对象的地址的指针。在复制结束之后，内存栈中储存的对象实际都指向内存堆中的同一个地址的值。当我们改变其中一个对象的值的时候，其实并不会改变内存栈中地址的值，而是会改变该地址指向的内存堆中那个对象的值，这就是为什么我们在改变obj1或者obj2的时候，另一个对象的值也会发生改变的原因了。 二、检测类型当我们要检测一个变量是什么类型的时候，我们常用typeof操作符。typeof操作符在检测基本属性类型的时候是最好的工具，即字符串、数值、布尔值、undefined等基本数据类型，但是当我们在检测一个变量的值是否是一个对象Object或者null的时候，typeof操作符就不适合了。 例子： 12345678910111213var s = "abcd"; //Stringvar b = false; //Booleanvar i = 22; //Numbervar u; //undefinedvar n = null; //nullvar o = &#123;&#125;; //Objectconsole.log("s:", typeof s); // 输出 s: stringconsole.log("b:", typeof b); // 输出 b: booleanconsole.log("i:", typeof i); // 输出 i: numberconsole.log("u:", typeof u); // 输出 u: undefinedconsole.log("n:", typeof n); // 输出 n: objectconsole.log("o:", typeof o); // 输出 o: object 当我们需要检测一个引用类型的值时，我们并不想知道某个值是对象，而是想知道它是什么类型的对象。因此，我们在检测引用类型是什么类型的对象的时候，可以使用instanceof操作符。 例子： 1234567var o = &#123;&#125;; //Objectvar a = []; //Arrayvar e = /^$/; //RegExpconsole.log("o:", o instanceof Object); // 输出 o: trueconsole.log("a:", a instanceof Array); // 输出 a: trueconsole.log("e:", e instanceof RegExp); // 输出 e: true 在检测一个引用类型值和Object构造函数的时候，instanceof操作符会返回true，但是如果我们使用instanceof操作符去检测基本类型的值时，始终会返回false，因为被检测的参数是基本类型而不是对象。 三、new Date()在safari上的坑在平常设置指定日期的时候我们常用new Date(&quot;yyyy-MM-dd HH:mm:ss&quot;)的格式将字符型的日期转换成Date类型，在大多数主流浏览器中都能正确的设置日期，但是在safari中却报错并返回Invalid Date。 所以当我们在使用new Date()之前，需要将日期字符串转换为safari所能识别的格式，具体有哪些格式大家可以去尝试，我个人推荐使用yyyy/MM/dd HH:mm:ss的格式，因为在IE8中不支持-的方式分割日期，推荐是用/进行分割。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客主题NexT相关配置]]></title>
    <url>%2F2019%2F02%2F27%2Fblog%2Fblog-theme-set%2F</url>
    <content type="text"><![CDATA[因为我的Hexo博客用的是NexT主题，故其他主题的配置我不是很清楚。 主题配置文件路径为：themes/next/_config.yml 一、主题风格以下操作均在_config.yml文件内进行。 修改scheme属性可以修改NexT主题的风格 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 修改menu属性可以修改主题的菜单项 1234567891011121314151617181920212223# ---------------------------------------------------------------# Menu Settings 菜单设置# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || home # 首页 about: /about/ || user # 关于 tags: /tags/ || tags # 标签 categories: /categories/ || th # 分类 archives: /archives/ || archive # 归档 #schedule: /schedule/ || calendar # 日程 #sitemap: /sitemap.xml || sitemap # 网站地图 #commonweal: /404/ || heartbeat# 是否使用网站icon# Enable/Disable menu icons.menu_icons: enable: true 添加tags(标签页)、categories(分类)、archives(归档)、about(关于)菜单项需要新建对应的页面，如果未新建对应的页面，点击菜单项跳转后会提示page not found，新建页面需要在网站根目录下打开终端，然后输入： 1234hexo n page "tages" # 新建标签页hexo n page "categories" # 新建分类页hexo n page "archives" # 新建归档页hexo n page "about" # 新建关于页 新建菜单页后会在source/下生成一个新的目录，目录名对应tags、categories等。 进入对应的目录下可以看到一个index.md文件，用编辑器打开之后内容为(此处用tags目录下的index.md做举例，其他的类似)： 1234---title: tagsdate: 2019-02-26 13:42:22--- 然后在date属性下面添加一个type属性，作用是设置该md文件的类型： 12345---title: tagsdate: 2019-02-26 13:42:22type: "tags" # 这是新添加的--- 二、引入评论功能Hexo支持多种评论平台，我使用的是Gitment，这是一个基于GitHub issues的第三方评论系统，他使用了你的GtiHub仓库中的issues作为评论系统。效果可以查看Gitment DEMO。 我选择Gitment的原因主要有： Gitment是基于GitHub issues开发的评论系统，而我的博客就是通过GitHub搭建的，使用起来会更加方便。 我的博客主要是用于记录我在JavaScript、VUE、Node.js等知识学习中遇到的一些问题以及我的学习心得，主要内容以代码为主，所以对GitHub的东西有一种“特殊”的感情。 Gitment的评论会直接添加在我对应的GitHub issues中，我在查看评论时会更加的方便。 接下来就开始我们的添加之旅吧~ 首先在博客 申请一个Github OAuth Application，注册地址 注意，在Authorization callback URL这一栏一定要填写你的网站url，即：`https://xxx.github.io` 注册成功之后你会获得一个Client ID和Client Secret，用于之后的Gitment评论系统登录。 修改NexT主题的配置文件，路径为：博客根目录/theme/_config.yml，找到Gitment属性（如果没有可以自行添加） 其中github_user是你的GitHub账户名，github_repo则是你这个仓库名（这个仓库名是用于存放你的评论位置的，一般用一个空仓库或者博客的仓库，不要在此填写仓库连接，填写仓库名就行了），client_id是我们在步骤2注册成功后GitHub给我们的Client ID，client_secret是刚才的Client Secret。注意：在:之后必须添加一个空格 在主题的根目录下我们打开~/layout/_third-party/comments/，在该目录下编辑gitment.swig文件内容（该文件一般为NexT主题自带）。我们需要将gitment的部分link的href更换，因为gitment使用的是GitHub的服务器，存在跨域的问题，原作者的网站证书失效了，所以我们需要修改并引用别人的.css和.js文件替换掉来解决跨域问题，要不然在登录gitment的时候会alert报错[object ProgressEvent]。 在这里我百度了一下问题，给大家列出两个解决方案： 修改浏览器设置，将https://gh-oauth.imsun.net/加入例外，但是别人浏览你的博客的时候不一定会添加。 修改~/layout/_third-party/comments/gitment.swing文件，将里面的https://imsun.github.io/gitment/style/default.css替换为https://www.wenjunjiang.win/css/gitment.css；https://imsun.github.io/gitment/dist/gitment.browser.js替换为https://www.wenjunjiang.win/js/gitment.js 使用方案2记得要将NexT主题的设置中的gitment下的mint属性修改为false 到这里基本你在你的博客博文下都能看到gitment的评论框了，不过使用之前还需要做两个步骤： 博客的主人需要登录并绑定对应的GitHub帐号； 登录之后需要对每篇博文下的评论功能进行初始化，需要一篇篇的点（无奈的表情渐渐浮现），不过网上有人写了批处理脚本，但是我没尝试过。 到了，到此Hexo+GitHub搭建博客的文章基本结束了，以后还有什么遇到的坑我会继续补充的。]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的设置]]></title>
    <url>%2F2019%2F02%2F27%2Fblog%2Fblog-set%2F</url>
    <content type="text"><![CDATA[一、Hexo配置文件说明 Hexo的配置文件位置是：~/_config.yml 在编辑配置文件的时候，在相应的设置项的:之后一定要添加一个空格。 其他一些详细的设置可以参考官方文档(中文) 在这里我着重讲解我的配置文件，可以作为你自己Hexo博客的配置参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息设置# Site# 网站标题title: HuangJunjia's Blog# 网站副标题subtitle: # 网站描述description:# 网站关键字keywords:# 网站作者昵称author: HuangJunjia# 网站语言，默认为英语，此处设置为简中language: zh-Hans# 时区，默认为电脑时区timezone:# 博客网址设置# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# 网址，如果你的博客是放在某个目录的子目录之下，需要将该设置修改为 'http://yoursite.com/child'url: http://yoursite.com# 根目录，如果你的博客是放在某个目录的子目录之下，需要将该设置修改为 '/child/'root: /# 文章链接地址格式 。即文章存放的目录。permalink: :year/:month/:day/:title/permalink_defaults:# 目录设置# Directory# 资源文件夹source_dir: source# 公共文件夹，用于存放 hexo g 生成的静态文件public_dir: public# 标签文件夹，默认为tags，路径为：./source/tagstag_dir: tags# 归档文件夹，默认为archives，路径为：./source/archivesarchive_dir: archives# 分类文件夹，默认为categories，路径为：./source/categoriescategory_dir: categories# 代码文件夹，默认为code，路径为：./downloads/codecode_dir: downloads/code# 国际化文件夹，默认跟language相同i18n_dir: :lang# 不需要渲染的文件夹或文件夹,放在[]中# 这两个文件是百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render:# 写作选项# Writing# 新建博文的默认名称new_post_name: :title.md # File name of new posts# 默认布局模版default_layout: post# 是否将标题转换成标题形式，即首字母大写titlecase: false # Transform title into titlecase# 在新标签页中打开网页external_link: true # Open external links in new tabfilename_case: 0# 是否渲染草稿render_drafts: false# 是否启动Asset文件夹post_asset_folder: true# 是否将链接改写成根目录的相对地址relative_link: false# 是否显示未来的文章future: true# 博文中代码块的设置highlight: enable: true # 是否使代码高亮 line_number: true # 是否显示行号 auto_detect: false # 是否自动检测语言 tab_replace: # 分页设置# @-----以下设置需要安装对应插件：# hexo-generator-index# hexo-generator-archive# hexo-generator-category# hexo-generator-tag# @-----END# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)# 首页分页设置index_generator: path: '' per_page: 10 # 首页每页显示文章数 order_by: -date # 分类与标签# Category &amp; Tag# 默认分类default_category: uncategorized# 分类别名category_map:# 标签别名tag_map:# 日期 / 时间格式# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示文章数pagination_dir: page # 分页路径，在public中可以查看# 主题设置# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next # 选择主题# 部署设置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 部署类型 repo: git@github.com:HuangJunjia/HuangJunjia.github.io.git # 部署连接地址 branch: master # 部署到git的分支名 # 搜索配置# 该功能需要提前安装插件# hexo-generator-search# searchsearch: path: search.xml field: post # post为仅索引文章，若想索引全部则设置为all format: html limit: 10000 二、如何安装Hexo的主题 Hexo默认主题是landscape 若需要修改主题，可以在Hexo官方主题中下载你想安装的主题 将下载好的主题放入themes目录下 我选择的主题是NexT 三、添加引入图片的功能先吐槽一下Hexo，他的图片引入功能很坑，用相对路径的方式引入图片会发现引入失败。我们需要在博客根目录下安装插件hexo-asset-image，之后我们通过hexo n &quot;new file&quot;的时候会在_post目录下生成一个同名的目录，我们将需要引入的图片放入那个目录下，之后引用图片就可以用相对路径引入了 1![img name](newFile/img.png) 三、参考博文《hexo教程系列——hexo配置教程》 下一篇博文将会介绍一些NexT主题的相关配置]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建一个Blog]]></title>
    <url>%2F2019%2F02%2F26%2Fblog%2Fblog-build%2F</url>
    <content type="text"><![CDATA[今天突发奇想，自己搭建一个blog就可以不用github那个markdown来撰写我的博文了，然后去百度搜了一下，网友推荐了使用Hexo（当然还有其他）搭建一个自己的blog。 一、前期准备 一个GitHub帐号 一个名称为YourName.github.io的仓库 安装Git 安装Node.js 安装Hexo 前4步操作直接百度就好，我在此主要讲建立Blog的主要过程以及一些需要注意的问题和坑。因为我个人使用的是Windows的系统，在此不讲解其他系统的搭建过程，但是大同小异，可以参考。 二、安装Hexo 在确保你安装好Node的前提下，并且能在终端中输入npm -v出现版本信息之后，在终端中输入： 1npm install hexo-cli -g 然后在终端中输入： 1hexo v 若出现下图则说明你已经成功安装Hexo。 创建一个目录，作为你的blog目录。 进入该目录。 初始化该目录，初始化的过程可能会稍微花费一些时间； 1hexo init 当终端中显示INFO Start blogging with Hexo!的时候说明初始化成功了。 安装Hexo运行所需要的相关组件及依赖； 1npm install //或者 yarn 我个人推荐使用后者 如果终端中未出现ERROR等错误提示，WARN警告我们直接忽略就好。 在终端中输入： 1hexo s 启动服务器， 如此显示说明Hexo已经启动了，我们就可以进入有下划线的网址http://localhost:4000浏览我们的博客长啥样了。 到此为止，Hexo的安装已经结束了。 三、将我们的Hexo博客部署在我们的Username.github.io仓库中 新建一个仓库，仓库名必须为xxx.github.io，一般xxx与你GitHub昵称相同。 因为Hexo部署需要通过GitHub的ssh连接，所以需要配置一个ssh key，配置方法百度即可。 安装hexo-deployer-git插件（非常重要） 1npm install hexo-deployer-git //或者 yarn add hexo-deployer-git 修改Hexo的配置文件_config.yml，连接你的GitHub仓库， type设置为git，repo填写你的GitHub仓库地址，branck填写master 在终端中按住ctrl + c结束正在运行的Hexo服务，然后输入： 1hexo g //生成部署的文件，在public目录下 接着输入： 1hexo d //将生成的部署文件上传到我们之前新建的GitHub仓库中 因为打印的日志有点多，我就截取主要部分。 出现最后一行说明我们已经成功的将我们的Hexoblog部署到我们的GitHub仓库中了。 这时我们可以打开GitHub进入我们的仓库查看上传的文件有哪些。 到这里就差最后一步了！ 修改GitHub仓库设置，在GitHub Pages中修改选中的分支，将分支修改为master branch，等待页面刷新之后，我们就可以拿到https://xxx.github.io这个网址了~（这里因为我之前有建立过blog，所以就直接拿我之前blog的设置来做例子了~） 这个时候，我们打开网址，即https://xxx.github.io，就可以看到我们的Hexo博客了！记得xxx是你当初设置的~记得替换。（可能在设置完GitHub Pages之后需要等个几分钟才能看到我们的页面） 四、安装过程中可能会碰到的问题 问题1：4000端口被占用，无法启动服务 解决方法：改变服务器的端口号 1hexo s -p 端口号 // 端口号可以是未被占用的 五、后记可能会有一些小细节没处理好，如果按照我的方法出现部署失败的，可以在评论里留言，我一定会认真回复的。 下一篇文章我将会讲解Hexo的一些设置以及NexT主题的相关设置，增加评论功能等。]]></content>
      <categories>
        <category>Hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐 for electron开发日记]]></title>
    <url>%2F2019%2F02%2F26%2FNeteseCloudMusic%2FFullApp%2FNeteseCloudMusicDiary%2F</url>
    <content type="text"><![CDATA[简介：使用electron-vue模版开发，非常感谢@Greg Holguin大大的electron-vue项目，以及使用的网易云音乐nodejs版的api的作者@Binaryify大大，他们俩是促使我尝试制作这个项目的原因。 项目地址网易云音乐 for electron 开发进度 header部分 logo区域： 已完成 icon的设置，title的设置 未完成 无 search区域： 已完成： 样式设计和编写 input事件触发搜索结果 未完成： 点击搜索图标跳转至搜索结果页面未制作 点击input触发的推荐结果跳转至对应的结果页未制作 setting区域： 已完成： 完成图标的制作 未完成： 对应功能未实现 视窗操作区域： 已完成： 图标按钮 当前窗口最小化、最大化/还原、关闭操作 未完成： 无 项目开发流程一、前期准备 node.js 官网 vue 官网 electron-vue模版 项目地址 该项目的目的，是为了要避免使用 vue 手动建立起 electron 应用程序。electron-vue 充分利用 vue-cli 作为脚手架工具，加上拥有 vue-loader 的 webpack、electron-packager 或是 electron-builder，以及一些最常用的插件，如vue-router、vuex 等等。 以上为官网介绍。 安装方式： 12345678# 安装 vue-cli 和 脚手架样板代码npm install -g vue-clivue init simulatedgreg/electron-vue my-project# 安装依赖并运行你的程序cd my-projectyarn # 或者 npm installyarn run dev # 或者 npm run dev 拉取网易云音乐 Node.js API service的github项目 项目地址 1git clone https://github.com/Binaryify/NeteaseCloudMusicApi.git 二、将网易云音乐API整合到electron-vue项目中并能够顺利启动服务该项目的网易云API是已经封装好的，但是需要单独的启动node.js，端口为3000，这样会显得比较麻烦，直接使用一个node.js的配置文件就足够了。 ps：因为该项目目前还在保持更新，若大家怕在后续的更新中需要重新修改配置，推荐大家直接在网易云API中直接启动node服务，我这里只是提供了我需要的一种方式。 过程： 拷贝网易云音乐API目录下的./module和./util目录，复制到electron-vue项目根目录下，此时目录结构应该如下： 12345678910electron-vue |-- .electron-vue |-- build |-- dist |-- node_modules |-- module |-- src |-- static |-- util ... 将网易云音乐API目录下app.js中的代码复制到electron-vue目录下的.electron-vue/dev-runner.js中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182......const fs = require('fs')const express = require('express')const bodyParser = require('body-parser')const request = require('../util/request')const cache = require('apicache').middleware......# 以下为网易云API的node服务代码const app = express()// CORSapp.use((req, res, next) =&gt; &#123; if(req.path !== '/' &amp;&amp; !req.path.includes('.'))&#123; res.header(&#123; 'Access-Control-Allow-Credentials': true, 'Access-Control-Allow-Origin': req.headers.origin || '*', 'Access-Control-Allow-Headers': 'X-Requested-With', 'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS', 'Content-Type': 'application/json; charset=utf-8' &#125;) &#125; next()&#125;)// cookie parserapp.use((req, res, next) =&gt; &#123; req.cookies = &#123;&#125;, (req.headers.cookie || '').split(/\s*;\s*/).forEach(pair =&gt; &#123; let crack = pair.indexOf('=') if(crack &lt; 1 || crack == pair.length - 1) return req.cookies[decodeURIComponent(pair.slice(0, crack)).trim()] = decodeURIComponent(pair.slice(crack + 1)).trim() &#125;) next()&#125;)// body parserapp.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123;extended: false&#125;))// cacheapp.use(cache('2 minutes', ((req, res) =&gt; res.statusCode === 200)))// staticapp.use(express.static(path.join(__dirname, 'public')))// routerconst special = &#123; 'daily_signin.js': '/daily_signin', 'fm_trash.js': '/fm_trash', 'personal_fm.js': '/personal_fm'&#125;fs.readdirSync(path.join(__dirname, '../module')).reverse().forEach(file =&gt; &#123; if(!(/\.js$/i.test(file))) return let route = (file in special) ? special[file] : '/' + file.replace(/\.js$/i, '').replace(/_/g, '/') let question = require(path.join(__dirname, '../module', file)) app.use(route, (req, res) =&gt; &#123; let query = Object.assign(&#123;&#125;, req.query, req.body, &#123;cookie: req.cookies&#125;) question(query, request) .then(answer =&gt; &#123; console.log('[OK]', decodeURIComponent(req.originalUrl)) res.append('Set-Cookie', answer.cookie) res.status(answer.status).send(answer.body) &#125;) .catch(answer =&gt; &#123; console.log(answer) console.log('[ERR]', decodeURIComponent(req.originalUrl)) if(answer.body.code =='301') answer.body.msg = '需要登录' res.append('Set-Cookie', answer.cookie) res.status(answer.status).send(answer.body) &#125;) &#125;)&#125;)const port = 3000 //在这里修改端口号app.server = app.listen(port, () =&gt; &#123; console.log(`server running @ http://localhost:$&#123;port&#125;`)&#125;)module.exports = app 20190201更新： 我将网易云音乐API node服务放在了我的服务器上，所以我这里直接使用我的服务器地址。 &lt;font color=#ff0000&gt;推荐为网易云API单独启动一个node服务，然后通过pm2进行管理。&lt;/font&gt; 启动electron-vue的node服务 1yarn dev //或者 npm run dev 此时控制台应打印出 稍等一会你会看到一个electron应用自动启动，说明node服务正式配置完毕。 四、electron服务配置反向代理 因为在electron-vue中需要用到网易云音乐API服务器的接口，但是网易云音乐API服务器端口为3000（或许你自定了一个端口），如果直接调用，会报跨域的错误，提示404 此时需要在electron-vue的.electron-vue/dev-runner.js中的electron服务中配置一个代理： 1234567891011121314151617181920212223242526272829/*--------------- electron-vue的node服务 -----------------*/function startRenderer () &#123; return new Promise((resolve, reject) =&gt; &#123; ...... const server = new WebpackDevServer( compiler, &#123; contentBase: path.join(__dirname, '../'), quiet: true, before (app, ctx) &#123; app.use(hotMiddleware) ctx.middleware.waitUntilValid(() =&gt; &#123; resolve() &#125;) &#125;, /*---- 以下是添加的代理设置 ----*/ proxy: &#123; "/api": &#123; target: 'http://localhost:3000', //指向网易云音乐API nodejs 服务器地址 //也可以使用你自己的服务器地址，但是方法同理 pathRewrite: &#123;'^/api' : ''&#125;, changeOrigin: true &#125; &#125; /*---- 代理设置到此结束 ----*/ &#125; ) &#125;｝---- 三、遇到的问题及解决方案 问题：在使用tray设置托盘的时候，在dev环境下能正常运行，但是打包成.exe文件之后提示icon错误。 原因：需要引入electron中的nativeImage模块，将icon转换成原生的图片。 解决方案： 原代码： 1tray = new Tray(`file://$&#123;__dirname&#125;/build/icon.ico`); 修改之后： 1234const &#123; Tray, nativeImage &#125; = require('electron');const iconPath = path.join(__dirname, 'build/icon.ico');mainWindow.tray = new Tray(nativeImage.createFromPath(iconPath)); 问题：在electron-vue中的页面里使用vuex报错，提示undefind。 原因：在electron-vue中为了实现多窗口之间能共享vuex的数据，引入了一个vuex-electron的插件，修改了vuex的配置方式。 解决方案： 按照`vuex-electron`的方式设置vuex，在`src/renderer/store/modules`中新建一个`NewStore.js`，并在该文件内编写`state`、`mutations`、`actions` 1234567891011121314151617const state = &#123; // your state code&#125;const mutations = &#123; // your mutations code&#125;const actions = &#123; // your actions code&#125;export default &#123; state, mutations, actions&#125; 问题：跨域问题如何解决 原因：electron默认使用同源策略，故若请求了跨域接口，则会报错 解决方案： 首先在.electron-vue/dev-runner.js文件中的startRenderer函数内添加proxy属性 12345678910111213141516171819202122232425262728function startRenderer () &#123; ..... const server = new WebpackDevServer( compiler, &#123; contentBase: path.join(__dirname, '../'), quiet: true, before (app, ctx) &#123; app.use(hotMiddleware) ctx.middleware.waitUntilValid(() =&gt; &#123; resolve() &#125;) &#125;, // 增加以下代码 proxy: &#123; '/api': &#123; target: 'http://localhost:port', secure: false, changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125;, &#125; &#125; &#125; ) server.listen(9080) &#125;)&#125; 其次在src/main/index.js文件中的new BrowserWindow()方法中添加一个字段 1234567// 新建一个win窗口 mainWindow = new BrowserWindow(&#123; ...... webPreferences: &#123; webSecurity: false &#125;, &#125;)]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>网易云音乐</tag>
        <tag>electron-vue</tag>
        <tag>vue</tag>
        <tag>个人项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2019%2F02%2F26%2FGitStudy%2Fgit-study-1%2F</url>
    <content type="text"><![CDATA[使用git过程中的经验整理 因为最近在用git添加多个sshkey的时候报错了，使用ssh -V github.com的时候提示key不存在，在不存在的网站(google.com)中找到了解决方案，然后想了想，决定开一个blog专门记录使用git的时候出现的问题以及对应的解决方案。 一、添加多个sshkey 首先执行命令生成第一个git仓库的sshkey 1ssh-keygen -t rsa -C &quot;first-email@address.com&quot; 再次执行命令生成第二个git仓库的sshkey 1ssh-keygen -t rsa -C &quot;secound-email@address.com&quot; 注意，在生成不同的sshkey的时候记得给每个sshkey起不同的名字。 修改git配置 这一个操作有两个方法，一个是最常用的方法，也是随便搜索都能找到的方法： 方法1：在~/.ssh目录下新建一个config文件 1234567891011# first-websiteHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa# second-websiteHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 方法2：该方法是否规范我不太确定，但是这么做是修改了git里ssh的配置 修改git目录下的git/etc/ssh/ssh_config文件，在文件的最下面添加连接仓库用到的sshkey文件 12345678......# Added by git-extra# 在下方添加我们需要通过ssh连接的git仓库对应的sshkey文件IdentityFile ~/.ssh/github_id_rsaIdentityFile ~/.ssh/gitlab_id_rsaCiphers +aes128-cbc,3des-cbc,aes256-cbc,aes192-cbc 然后重启git 之后再连接不同的git仓库就能顺利的连接了 二、将Beyond Compare 4设置为difftool下载bc4之后在任意地方打开git bash然后输入以下命令： 12345678git config --global diff.tool bc4git config --global difftool.prompt falsegit config --global difftool.bc4.cmd '"C:\Program Files\Beyond Compare 4\BCompare.exe" "$LOCAL" "$REMOTE"'git config --global merge.tool bc4git config --global mergetool.prompt falsegit config --global mergetool.bc4.cmd '"C:\Program Files\Beyond Compare 4\BCompare.exe" "$LOCAL" "$REMOTE" "$BASE" "$MERGED"'git config --global mergetool.bc4.trustexitcode true]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue大转盘组件]]></title>
    <url>%2F2019%2F02%2F26%2Fcomponents%2FLotteryComponent%2FLottery%2F</url>
    <content type="text"><![CDATA[这是一个大转盘抽奖组件，可以自定义盘面，包括颜色、字体、图片等内容。 感谢@木子七大佬的大转盘文章这里是连接，在之后的使用中发现不能设置奖品并将奖品转动到对应的扇形盘面上，对此我进行了修改，使其可以在vue中正常使用，可能修改的并不好，希望各位指出。 实现过程我就不再重复编辑了，木子七大佬的文章中以及他的github中对大转盘的实现有详细的描述以及代码实现。在此我只对我改进的部分代码进行示例以及解释。 一、解决大转盘清晰度 方案1：该方案出自@boluobanana的简书文章，非常感谢大佬。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Writes an image into a canvas taking into * account the backing store pixel ratio and * the device pixel ratio. * * @author Paul Lewis * @param &#123;Object&#125; opts The params for drawing an image to the canvas*/function drawImage(opts) &#123; if(!opts.canvas) &#123; throw("A canvas is required"); &#125; if(!opts.image) &#123; throw("Image is required"); &#125; // get the canvas and context var canvas = opts.canvas, context = canvas.getContext('2d'), image = opts.image, // now default all the dimension info srcx = opts.srcx || 0, srcy = opts.srcy || 0, srcw = opts.srcw || image.naturalWidth, srch = opts.srch || image.naturalHeight, desx = opts.desx || srcx, desy = opts.desy || srcy, desw = opts.desw || srcw, desh = opts.desh || srch, auto = opts.auto, // finally query the various pixel ratios devicePixelRatio = window.devicePixelRatio || 1, // backingStoreRatio此属性已被弃用 // backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1, // ratio = devicePixelRatio / backingStoreRatio; ratio = devicePixelRatio; // ensure we have a value set for auto. // If auto is set to false then we // will simply not upscale the canvas // and the default behaviour will be maintained if (typeof auto === 'undefined') &#123; auto = true; &#125; // upscale the canvas if the two ratios don't match // if (auto &amp;&amp; devicePixelRatio !== backingStoreRatio) &#123; if (auto &amp;&amp; devicePixelRatio) &#123; var oldWidth = canvas.width; var oldHeight = canvas.height; canvas.width = oldWidth * ratio; canvas.height = oldHeight * ratio; canvas.style.width = oldWidth + 'px'; canvas.style.height = oldHeight + 'px'; // now scale the context to counter // the fact that we've manually scaled // our canvas element context.scale(ratio, ratio); &#125; context.drawImage(pic, srcx, srcy, srcw, srch, desx, desy, desw, desh);&#125; 方案2：精简版代码 123456789101112131415161718192021let getPixelRatio = function (context) &#123; let backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1; return (window.devicePixelRatio || 1) / backingStore;&#125;;let ratio = getPixelRatio(context);let fontSize = document.getElementsByTagName("html")[0].style.fontSize.split("px")[0] || 100;canvas.style.width = canvas.width / fontSize + 'rem';canvas.style.height = canvas.height / fontSize + 'rem';canvas.width = canvas.width * ratio;canvas.height = canvas.height * ratio;// 放大倍数context.scale(ratio, ratio); 以上两个方案均能解决canvas在高分屏上绘制出现模糊的问题。 二、预加载盘面图片在canvas中有多种加载图片的方式，常用的有以下两种方式： 方式一：通过new Image()声明一个Image对象，并通过src设置图片路径 12345678// 声明一个Image()对象let img = new Image();// 设置Image对象的srcimg.src = "path/icon.png";// 在canvas中绘制图片ctx.drawImage(img, 0, 0, imageWidth, imageHeight); 方式二：首先通过&lt;img&gt;标签向html中插入一张图片，然后使用getElementById获取这个img元素，再执行绘图 1234&lt;!-- 在html页面中插入img元素 --&gt;&lt;body&gt; &lt;img id="img" style="display:none;" src="path/icon.png"&gt;&lt;/body&gt; 12345// 获取页面中的html元素let img = document.getElementById("img");// 在canvas中绘制图片ctx.drawImage(img, 0, 0, imageWidth, imageHeight); 讲到这里，有必要提一下这里碰到的一个问题，通过方式一在canvas中绘图一张图片时，发现并不能成功绘制，而通过方式二绘制的时候却能正常显示。 这是因为canvas在绘制图片的时候需要 等图片加载成功之后才可以进行绘制，drawImage()这个方法在图片未加载完成的时候是不会被调用的，所以导致了绘图失败。 我们该如何解决这个问题呢？我百度并尝试了多种方式，最后总结了三种方法用于解决这个问题： 方法一：&lt;img&gt;标签和window.onload配合使用 12&lt;!-- html代码 --&gt;&lt;img src=""&gt; 1234// JavaScript代码window.onload = function() &#123; context.drawImage();&#125; 或者在后期插入标签： 1234let img = document.createElement("img");img.src = "path";document.body.appendChild(img);context.drawImage(img, 0, 0, width, height); 方法二：使用定时器setTimeout()异步实现 123setTimeout(function() &#123; context.drawImage(img, 0, 0, width, height);&#125;, 10) 延迟时间需要根据不同的情况设定，所以用定时器去解决这个方案是有弊端的，不能保证定时器时间到了之后图片能正常加载，若出现网络较差的情况还是会遇到无法加载的情况。 方式三：使用img.onload监听图片加载结束 12345img.onload = function()&#123; console.log('图片加载成功'); console.log(this); context.drawImage(img, 0, 0, width, height);&#125; 使用onload监听img的加载，加载结束之后再执行图片的绘制，目前最靠谱的方式就是这个。 需要注意的是onload是一个异步任务。 我使用的是img标签加onload监听图片加载的方式 12&lt;!-- html代码 --&gt;&lt;img id="img" src="path"&gt; 1234567// JavaScript代码let img = document.getElementById("img"); //获取imgimg.onload = function() &#123; //监听img是否加载结束 console.log('图片加载成功'); console.log(this); context.drawImage(img, 0, 0, width, height); //绘制图片&#125; 三、大转盘盘面相关修改 去掉@木子七大佬原来的触发按钮以及使用canvas绘制的指针，并添加一个透明的div用于给用户”点击”。 123456789101112131415161718192021222324&lt;template&gt; &lt;div class="canvas-main"&gt; &lt;div id="spin_button"&gt;&lt;/div&gt; &lt;!-- 这是一个透明的“点击”按钮 --&gt; &lt;div id="spin_button_mask" @click="clickBtn"&gt;&lt;/div&gt; &lt;canvas id="canvas" width="300" height="300"&gt; &lt;/canvas&gt; &lt;div style="display: none"&gt; &lt;img id="prize1" src="prize01.png" width="100"&gt; &lt;img id="prize2" src="prize02.png" width="100"&gt; &lt;img id="prize3" src="prize03.png" width="100"&gt; &lt;img id="prize4" src="prize04.png" width="100"&gt; &lt;img id="prize5" src="prize05.png" width="100"&gt; &lt;img id="prize6" src="prize06.png" width="100"&gt; &lt;img id="prize7" src="prize07.png" width="100"&gt; &lt;img id="pointer-red" src="red-pointer.png" width="158"&gt; &lt;img id="pointer-gray" src="gray-pointer.png" width="158"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 在&lt;canvas&gt;标签中添加文字说明，用于当浏览器不兼容canvas标签的时候的提示 --&gt; 加载转盘奖品图片和按钮图片 123456789101112131415161718192021222324252627282930313233343536373839// ---- 加载所有图片，目前是写死用的，可以删除// 因为onload是异步操作，故每加载一张图片则令imgFlag加一，当imgFlag === 9的时候说明9张图片加载完毕， 此时可以开始绘制转盘// 加载按钮图片let btn_img_red = document.getElementById(`pointer-red`);let btn_img_gray = document.getElementById(`pointer-gray`);let imgFlag = 0;let imgs = []; //此数组用于暂存奖品图片awards.forEach((item, index) =&gt; &#123; //遍历奖品数组并加载奖品图片 if (item.img) &#123; let imgObj = document.getElementById(`prize$&#123;index + 1&#125;`); imgs.push(imgObj); imgObj.onload = function () &#123; imgFlag++; if (imgFlag &gt;= 9) &#123; //判断一共9张图片是否全部加载完毕 console.log("开始绘制盘面"); drawRouletteWheel(); &#125; &#125; &#125; else &#123; imgs.push(null) &#125;&#125;);btn_img_red.onload = function () &#123; imgFlag++; if (imgFlag &gt;= 9) &#123; //判断一共9张图片是否全部加载完毕 console.log("开始绘制盘面"); drawRouletteWheel(); &#125;&#125;;btn_img_gray.onload = function () &#123; imgFlag++; if (imgFlag &gt;= 9) &#123; //判断一共9张图片是否全部加载完毕 console.log("开始绘制盘面"); drawRouletteWheel(); &#125;&#125;; 绘制盘面相关内容，如奖品名称、奖品价格、奖品略缩图等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/*** 绘制转盘*/function drawRouletteWheel() &#123; // ----- ① 清空页面元素，用于逐帧动画 context.clearRect(0, 0, canvas.width, canvas.height); // ----- for (let i = 0; i &lt; awards.length; i++) &#123; let _startRadian = startRadian + awardRadian * i, // 每一个奖项所占的起始弧度 _endRadian = _startRadian + awardRadian; // 每一个奖项的终止弧度 // ----- ② 使用非零环绕原则，绘制圆盘 context.save(); if (i % 2 === 0) &#123; context.fillStyle = "#ffedee" &#125; else &#123; context.fillStyle = "#ffffff" &#125; context.beginPath(); context.arc(canvas.width / 2 / ratio, canvas.height / 2 / ratio, OUTSIDE_RADIUAS, _startRadian, _endRadian, false); context.arc(canvas.width / 2 / ratio, canvas.height / 2 / ratio, INSIDE_RADIUAS, _endRadian, _startRadian, true); context.fill(); context.restore(); // ----- // ----- ③ 绘制文字 context.save(); if (awards[i].img) &#123; context.font = _this.fontSize + "px bold"; &#125; else &#123; context.font = _this.fontSize + 4 + "px bold"; &#125; context.fillStyle = "#5e5d5d"; context.translate( CENTER_X + Math.cos(_startRadian + awardRadian / 2) * TEXT_RADIUAS, CENTER_Y + Math.sin(_startRadian + awardRadian / 2) * TEXT_RADIUAS ); context.rotate(_startRadian + awardRadian / 2 + Math.PI / 2); // 绘制图片，默认奖品在偶数位 if (awards[i].img &amp;&amp; imgs[i]) &#123; // context.drawImage(bgImg, -context.measureText(awards[i].name).width / 2,0,50,50); context.drawImage(imgs[i], -25, -65, 50, 50); &#125; // 名称 当奖品带有图片的时候调整字体绘制位置和大小等相关属性 if (awards[i].img) &#123; if (awards[i].AwardName.length &gt; 10) &#123; context.fillText(awards[i].AwardName, -context.measureText(awards[i].AwardName).width / 2, -5 * (awards[i].AwardName.length - 10)); &#125; else &#123; context.fillText(awards[i].AwardName, -context.measureText(awards[i].AwardName).width / 2, 0); &#125; &#125; else &#123; context.fillText(awards[i].AwardName, -context.measureText(awards[i].AwardName).width / 2, -20); &#125; // 价格 if (awards[i].MdseAmount) &#123; context.fillText(awards[i].MdseAmount, -context.measureText(awards[i].MdseAmount).width / 2, 16); &#125; context.restore(); // ----- &#125; // -----④绘制按钮 if (!_this.disabled) &#123; //disabled是控制"开始旋转"按钮是否可以点击的参数，当可以点击的时候绘制红色的按钮，当不可点击的时候绘制灰色的按钮 context.drawImage(btn_img_red, canvas.width / 2 / ratio - btn_img_red.width / 2 / ratio * 1.5, canvas.height / 2 / ratio - btn_img_red.height / 2 / ratio * 1.5, btn_img_red.width / ratio * 1.5, btn_img_red.height / ratio * 1.5) &#125; else &#123; context.drawImage(btn_img_gray, canvas.width / 2 / ratio - btn_img_gray.width / 2 / ratio * 1.5, canvas.height / 2 / ratio - btn_img_gray.height / 2.5 / ratio * 1.5, btn_img_gray.width / ratio * 1.5, btn_img_gray.height / ratio * 1.25) &#125; // ----- // ----- ④ 绘制指针 因指针使用自定义的按钮，并绘制在图片上，故原绘制指针的方法删除 // context.save(); // context.beginPath(); // context.moveTo(CENTER_X, CENTER_Y - OUTSIDE_RADIUAS + 8); // context.lineTo(CENTER_X - 10, CENTER_Y - OUTSIDE_RADIUAS); // context.lineTo(CENTER_X - 4, CENTER_Y - OUTSIDE_RADIUAS); // context.lineTo(CENTER_X - 4, CENTER_Y - OUTSIDE_RADIUAS - 10); // context.lineTo(CENTER_X + 4, CENTER_Y - OUTSIDE_RADIUAS - 10); // context.lineTo(CENTER_X + 4, CENTER_Y - OUTSIDE_RADIUAS); // context.lineTo(CENTER_X + 10, CENTER_Y - OUTSIDE_RADIUAS); // context.closePath(); // context.fill(); // context.restore(); // -----&#125; 开始旋转触发方法修改 123456789101112131415161718192021/*** 开始旋转*/function rotateWheel() &#123; // 当 当前时间 大于 总时间，停止旋转，并返回当前值 spinningTime += 20; if (spinningTime &gt;= spinTotalTime) &#123; _this.disabled = false; _this.$emit('end'); //当转盘停止转动的时候触发end回调 drawRouletteWheel(); //当结束的时候重新绘制一次转盘，保证按钮是可转动的状态对应的按钮 return &#125; else &#123; _this.disabled = true; &#125; let _spinningChange = (spinningChange - easeOut(spinningTime, 0, spinningChange, spinTotalTime)) * (Math.PI / 180); startRadian += _spinningChange; drawRouletteWheel(); window.requestAnimationFrame(rotateWheel);&#125; 监听点击事件，开始旋转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071_this.$refs["spin_button"].addEventListener("click", () =&gt; &#123; if (!_this.disable) &#123; //控制抽奖次数的参数 if (!_this.disabled) &#123; //控制是否重复点击的参数 // 获取奖品在数组中的下标 if (getIndex() !== false) &#123; listIndex = getIndex(); &#125; else &#123; console.error("请确定中奖奖品是否在奖品列表中"); _this.clear = false; return &#125; function getIndex() &#123; let i = null; let notWonIndex = null; _this.list.forEach((item, index) =&gt; &#123; if (item.AwardNo) &#123; // if (_this.prize === item.AwardNo) &#123; // i = index; // &#125; else if (item.AwardNo === "MDSE999999999999999") &#123; // notWonIndex = index; // &#125; if (_this.prize === item.AwardNo) &#123; i = index; &#125; else &#123; notWonIndex = index; &#125; &#125; else &#123; console.warn("请确认奖品编号字段是否存在") &#125; &#125;); if (!notWonIndex) &#123; console.warn("奖品编号不存在，自动设置为谢谢参与") &#125; if (i !== null) &#123; return i; &#125; else &#123; return notWonIndex; &#125; &#125; // 获取中奖奖品旋转的起始角度 turnStartRadian = awardRadian * listIndex; // 获取中奖奖品的起始角度 turnEndRadian = awardRadian * listIndex + awardRadian; // 获取中奖奖品的结束角度 spinningTime = 0; // 初始化当前时间 startRadian = 0; // 初始化弧度 spinTotalTime = 5 * 1000; // 随机定义一个时间总量 prizeAngle = awardRadian * 180 / Math.PI * Math.floor(Math.random() * 10 + 1) / 10; //该参数是确定奖品的对应角度(360°内) if (prizeAngle &gt; 0.7 * (360 / _this.list.length)) &#123; prizeAngle = 0.7 * (360 / _this.list.length) &#125; else if (prizeAngle &lt; 0.3 * (360 / _this.list.length)) &#123; prizeAngle = 0.3 * (360 / _this.list.length) &#125; spinningChange = (turnStartRadian * 180 / Math.PI - 90 * (listIndex + 1) % 360 - prizeAngle + 360 * turns) / 124.5; //根据相应的角度算出大转盘的旋转速率，保证转盘停止转动的时候能落在我们想落在的位置 rotateWheel(); &#125; else &#123; console.log('请勿重复点击') &#125; &#125; else &#123; console.log('今日抽奖次数已用完') &#125;&#125;); 以上的修改均在vue的mounted生命周期之内进行，此时需要进行相应的修改，整个vue组件大概结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name: "Lottery",props: &#123; // 获取数组 disable: &#123; type: Boolean, default: false &#125;, // 盘面奖品list list: &#123; type: Array, default: (val) =&gt; &#123; if (!val || val.length === 0) &#123; console.error("请确认转盘盘面奖项列表") &#125; &#125; &#125;, // 设置中奖奖项 prize: &#123; type: String, default: null &#125;, // 设置奖品字体 fontSize: &#123; type: Number, default: 16 &#125;, // 设置旋转圈数 turns: &#123; type: Number, default: 5 &#125;, // 控制转盘转动 run: &#123; type: Boolean, default: false &#125;&#125;,data() &#123; return &#123; disabled: false, //控制大转盘是否可以点击 &#125;&#125;,mounted() &#123; this.$nextTick(() =&gt; &#123; let _this = this; //将vue的this值赋予_this，目的是防止之后this被污染导致获取不到正确的值 // ......对应的代码 &#125;)&#125;,watch: &#123; run(val) &#123; //监听run的变化，当run变化的时候触发spin_button的click事件 if (val &amp;&amp; !this.disabled) &#123; this.$refs["spin_button"].click(); &#125; &#125;&#125;,methods: &#123; // 点击按钮遮罩 clickBtn() &#123; if (!this.run &amp;&amp; !this.disabled) &#123; console.log("开始旋转"); this.$emit('start') &#125; else &#123; console.error("请勿重复点击") &#125; &#125;,&#125; 四、效果图 本文部分内容转载自@木子七的大转盘文章]]></content>
      <categories>
        <category>vue组件</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>component</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象学习]]></title>
    <url>%2F2019%2F02%2F26%2FJavaScript%2FPromiseStudy%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise学习一、回调函数的问题学过 JavaScript 的人都应该清楚一件事，JavaScript语言的一大特点就是单线程，目的是为了提高效率。因此在 JavaScript 中回调函数不会立即执行，而是由事件轮询去检测事件是否执行完毕，当执行完毕并且有结果之后，将执行结果放入回调函数中，然后将回调函数添加到事件队列中等待被执行。 在这里会有一些关于回调函数的问题： “回调地狱”：即“洋葱模型”，回调函数作为异步函数的参数，会形成多级的嵌套，当嵌套级数过多时，代码逻辑会变得混乱，无法将错误的捕捉和处理这个简单的工作做好，只能在回调函数的内部通过try{}...catch(){}捕获并处理异常。 回调函数的执行方式不符合自然语言的线性思维方式，不易理解。 控制反转，即控制权不在我们手中，而是在其他人的代码中。例如该异步函数是第三方库，当我们把回调函数传给第三方库的时候，我们并不能知道我们的异步函数在第三方库里做了什么，在调用回调函数之前做了什么。 解决回调函数的问题有很多种方法，其中比较好的一种方式就是使用 Promise 对象。 二、什么是PromisePromise 是目前在 JavaScript 异步编程中比较流行的解决方案之一，Promise 用于表示一个异步操作的最终状态（完成或者失败），并且可以链式的处理异步请求（.then()方法），很好的处理异常问题，是解决回调地狱的良好方案之一。MDN对 Promise 的解释如下： Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise对象。 三、Promise 的状态Promise 一共包含有三种状态： pending：初始状态，既不是成功状态，也不是失败状态，在网上多数人称为等待中状态。 fulfilled：成功状态，意味着操作成功完成。 rejected：失败状态，意味着操作失败。 Promise 无论如何都会返回一个结果，不是成功，就是失败。并且 Promise 的设计具有原子性，即当状态从pending状态转变为fulfilled状态或者rejected状态后，将不能改变。 在pending状态中，Promise 可能触发fulfilled状态并将成功结果传递给相应的状态处理方法，也可能触发rejected状态并将失败信息返回。 (图片来自@MDN) 四、Promise 的原理从本文前面的内容中可知 Promise 有三个状态，并且会返回一个成功或者失败的结果。 (图来自于https://juejin.im/post/5c724f14518825626b76f6d5) 12345678910111213141516171819202122232425262728293031var promise = new Promise((resolve, reject) =&gt; &#123; console.log("Promise构造器执行"); setTimeout(() =&gt; &#123; if (true) &#123; resolve("成功"); &#125; else &#123; reject("失败"); &#125; &#125;, 1000)&#125;)promise.then((result) =&gt; &#123; console.log(result); return 1; // return Promise.resolve(1); // 返回一个决议为成功的 Promise 实例 // return Promise.reject("error"); // 返回一个决议为拒绝的 Promise 实例&#125;).then((result) =&gt; &#123; // .then() 方法会返回一个 Promise, 完成调用的参数为前一个 Promise 的返回值或者决议值。 console.log(result); throw new Error("抛出错误"); // 抛出错误是隐式拒绝&#125;).catch((error) =&gt; &#123; console.log(error);&#125;).then(() =&gt; &#123; // Continue to do other things&#125;).finally(() =&gt; &#123; console.log("finally");&#125;) 五、Promise 的语法1new Promise( function(resolve, reject) &#123;...&#125; /* executor */ ); 参数： executor： executor函数带有resolve和reject两个参数。当 Promise 构造函数在执行时会立即调用executor函数，executor函数在 Promise 构造函数返回新建对象之前会被调用，并将resolve和reject两个函数作为参数传递给executor函数。在executor函数内部通常会执行一些异步操作，并在异步操作完成时调用resolve函数或者reject函数将 promise 的状态修改为fulfilled(成功)或者rejected(失败) 只要在executor函数中抛出一个错误，promise 的状态就会转换为rejected，此时executor函数的返回值将会被忽略。 六、Promise 的属性 Promise.length： Promise 的 length 属性，其值始终为 1，即构造器参数的数目。 Promise.prototype： Promise 构造器的原型。 七、Promise 的方法 Promise.all(iterable)： 当 promise 对象中 iterable 参数对象里所有的 promise 对象都成功执行的时候触发的一个方法，若 iterable 中有任何一个 promise 对象执行失败则会立即触发该 promise 对象的失败。该方法在触发成功状态之后，会将 iterable 参数里所有 promise 对象返回值放入一个数组中并将该数组作为成功回调的返回值，该数组中各个 promise 对象的返回值顺序与 iterable 的顺序保持一致。如果触发了失败状态，则该方法会将第一个触发失败状态的 promise 对象的错误信息作为它的错误信息返回。该方法常用于处理多个 promise 对象的状态合集。 Promise.race(iterable)： iterable 参数中只要有一个 promise 对象触发了额成功状态或者失败状态，就会将该 promise 对象的值作为它的返回值。 Promise.reject(reason)： 返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法。 Promise.resolve(value)： 返回一个状态由给定 value 决定的 Promise 对象。如果该值是一个 Promise 对象，则直接返回该对象；如果该值是 thenable (即，带有.then()方法的对象)，返回的 Promise 对象的最终状态由.then()方法执行决定；否则的话(该 value 为空，基本类型或者不带.then()方法的对象)，返回的 Promise 对象状态为fulfilled，并且将该 value 传递给对应的.then()方法。通常而言，如果你不知道一个值是否是 Promise 对象，使用Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。 八、Promise 的原型 属性： Promise.prototype.construtor： 返回被创建的实例函数. 默认为 Promise 函数。 方法： Promise.prototype.catch(onRejected)： 当.then()方法中发生错误时，.catch()方法会捕获并处理错误，并将一个rejection(拒绝)回调到当前的 promise，然后返回一个新的 promise。新的 promise 以.catch()的返回值来 resolve。 Promise.prototype.then(onFulfilled, onRejected)： 在当前的 promise 中添加fulfilled(解决)回调和rejuection(拒绝)回调，并以回调的返回值来 resolve。 Promise.prototype.finally(onFinally)： 无论 promise 的状态是处于fulfilled(成功)状态还是rejected(失败)状态，都会调用的一个方法，并且在该回调中返回一个新的 promise 对象。 九、Promise 的优势 链式调用： Promise 在使用后会返回一个新的 Promise 便于我们传递状态参数。同时因为其链式的写法更接近于同步写法，更加符合线性思维。 错误捕捉： Promise 能够为链式异步调用提供错误处理。 控制权的再次反转： 第三方提供的异步函数我们无法保证回调函数如何被执行，但是通过 Promise 我们能够保证 resolve 只会执行一次，并且 Promise 始终以异步的形式执行。 解决未决议和并行嵌套的问题： Promise 的Promise.all(iterable)方法和Promise.race(iterable)方法可以用于解决 Promise 始终未决议和并行 Promise 嵌套的问题。 十、Promise对象的不足 每个.then()方法都是一个独立的作用域： 当我们加入多个.then()方法时，会创建多个独立的作用域，要想解决作用域的数据共享问题需要在外层包裹一层函数作用域实现闭包。 .then()无法取消： .catch()能捕获并处理 Promise 链中任意一个.then()方法中的错误，但是不会中断整个 Promise 链的执行。 无法得知进度： Promise 只会从pending状态转变为fullfilled状态或者rejected状态，所以我们无法得知pending阶段的进度。 十一、应用 Promise 的简单例子123456789101112131415161718192021222324252627282930313233343536// 使用 Promise 对ajax进行封装function fetch(method, url, data)&#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); var method = method || "GET"; var data = data || null; xhr.open(method, url, true); xhr.onreadystatechange = function() &#123; if(xhr.status === 200 &amp;&amp; xhr.readyState === 4)&#123; resolve(xhr.responseText); &#125; else &#123; reject(xhr.responseText); &#125; &#125; xhr.send(data); &#125;)&#125;// 使用fetch("GET", "/api", null).then(result =&gt; &#123; console.log(result);&#125;)// 封装 nodejs error first 风格回调function readFile(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url,'utf8', (err, data) =&gt; &#123; if(err) &#123; reject(err); return; &#125; resolve(data) &#125;) &#125;)&#125; 参考资料（排名不分先后顺序） @南波的《JS异步编程之Promise》 @南波的《JS异步编程之callback》 @蟹丸的《前端异步技术之Promise》 MDN的Promise文档]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
